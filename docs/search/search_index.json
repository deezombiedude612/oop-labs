{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ITS42004 Object-Oriented Programming This site hosts the practical lab work for ITS42004: Object-Oriented Programming, offered by the School of Pre-University Studies at Taylor's College. Aim The aim of these practical lab exercises is to guide the students through programming in an object-oriented paradigm. Schedule (April 2022 Semester) The schedule is subject to change. Week Lecture Practical Lab Remarks 1 18 Apr - 22 Apr Introduction to Java Practical Preparation 2 25 Apr - 29 Apr Fundamentals of Java Structure Practical 1 3 2 May - 6 May Program Control Structure (Part 1): Selection Statements Practical 2 Independent Learning Week 4 9 May - 13 May Program Control Structure (Part 2): Loop Statements Practical 3 5 16 May - 20 May Arrays and ArrayList Practical 4 6 23 May - 27 May Methods Practical 5 7 30 May - 3 June OOP Principles (Part 1): Designing Classes Practical 6 8 6 June - 10 June OOP Principles (Part 2): Inheritance Practical 7 Assignment 1 Due 9 13 June - 17 June OOP Principles (Part 3): Polymorphism Practical 8 10 20 June - 24 June OOP Principles (Part 4): Abstract Classes & Interfaces Practical 9 11 27 June - 1 July Tutorial Work - Revision Practical Test 12 4 July - 8 July Exception Handling Practical 10 13 11 July - 15 July File I/O Practical 11 Assignment 2 Due 14 18 July - 22 July Wrap-up Lecture and FE Briefing Tutorial - Revision Note The practical work is arranged such that it complements the respective weeks' lectures. It is encouraged that you ensure that you're familiar with the lecture content before attempting the practical work.","title":"Home"},{"location":"#aim","text":"The aim of these practical lab exercises is to guide the students through programming in an object-oriented paradigm.","title":"Aim"},{"location":"#schedule-april-2022-semester","text":"The schedule is subject to change. Week Lecture Practical Lab Remarks 1 18 Apr - 22 Apr Introduction to Java Practical Preparation 2 25 Apr - 29 Apr Fundamentals of Java Structure Practical 1 3 2 May - 6 May Program Control Structure (Part 1): Selection Statements Practical 2 Independent Learning Week 4 9 May - 13 May Program Control Structure (Part 2): Loop Statements Practical 3 5 16 May - 20 May Arrays and ArrayList Practical 4 6 23 May - 27 May Methods Practical 5 7 30 May - 3 June OOP Principles (Part 1): Designing Classes Practical 6 8 6 June - 10 June OOP Principles (Part 2): Inheritance Practical 7 Assignment 1 Due 9 13 June - 17 June OOP Principles (Part 3): Polymorphism Practical 8 10 20 June - 24 June OOP Principles (Part 4): Abstract Classes & Interfaces Practical 9 11 27 June - 1 July Tutorial Work - Revision Practical Test 12 4 July - 8 July Exception Handling Practical 10 13 11 July - 15 July File I/O Practical 11 Assignment 2 Due 14 18 July - 22 July Wrap-up Lecture and FE Briefing Tutorial - Revision Note The practical work is arranged such that it complements the respective weeks' lectures. It is encouraged that you ensure that you're familiar with the lecture content before attempting the practical work.","title":"Schedule (April 2022 Semester)"},{"location":"lab00/","text":"Practical Preparation Integrated Development Environment (IDE) Going forward, I will be using IntelliJ IDEA by Jetbrains as my IDE of choice during demos. However, this is not the only choice available - some good alternatives include Eclipse, Netbeans, and Visual Studio Code. Of course, you are not forbidden to use a different code editor you're already familiar with, as long as you are able to write Java programs with it. Installing Java JDK Before installing the IDE of your choice, you will need to install the Java Development Kit (JDK) first. Here are some video tutorials on how to install the JDK in your machine. How to Install JDK for Amazon Corretto for Windows How to Install JDK for Amazon Corretto for macOS How to Install JDK for Amazon Corretto for Linux Setting Up IntelliJ IDEA As mentioned earlier, the program I will be using is IntelliJ IDEA. Here are some video tutorials on how to install IntelliJ IDEA in your machine. How to Install IntelliJ in Windows How to Install IntelliJ in macOS How to Install IntelliJ in Linux Upon installing IntelliJ IDEA in your machine, there are a few configurations you will need to carry out before starting to use IntelliJ IDEA. The following video tutorial will help you get to speed in setting up IntelliJ IDEA before starting to program. IntelliJ Configuration on Mac, Linux and Windows Testing IntelliJ IDEA Create different Java files to contain each of the following code snippets. Ensure that the code runs properly. Demo1 Demo1.java 1 2 3 4 5 6 7 public class Demo1 { public static void main ( String [] args ) { System . out . println ( \"Welcome \" ); System . out . println ( \"To \" ); System . out . println ( \"OOP Class\" ); } } Demo2 Demo2.java 1 2 3 4 5 6 public class Demo2 { public static void main ( String [] args ) { System . out . println ( \"3.5 * 4 / 2 - 2.5 is \" ); System . out . println ( 3.5 * 4 / 2 - 2.5 ); } }","title":"Practical Preparation"},{"location":"lab00/#practical-preparation","text":"","title":"Practical Preparation"},{"location":"lab00/#integrated-development-environment-ide","text":"Going forward, I will be using IntelliJ IDEA by Jetbrains as my IDE of choice during demos. However, this is not the only choice available - some good alternatives include Eclipse, Netbeans, and Visual Studio Code. Of course, you are not forbidden to use a different code editor you're already familiar with, as long as you are able to write Java programs with it.","title":"Integrated Development Environment (IDE)"},{"location":"lab00/#installing-java-jdk","text":"Before installing the IDE of your choice, you will need to install the Java Development Kit (JDK) first. Here are some video tutorials on how to install the JDK in your machine.","title":"Installing Java JDK"},{"location":"lab00/#how-to-install-jdk-for-amazon-corretto-for-windows","text":"","title":"How to Install JDK for Amazon Corretto for Windows"},{"location":"lab00/#how-to-install-jdk-for-amazon-corretto-for-macos","text":"","title":"How to Install JDK for Amazon Corretto for macOS"},{"location":"lab00/#how-to-install-jdk-for-amazon-corretto-for-linux","text":"","title":"How to Install JDK for Amazon Corretto for Linux"},{"location":"lab00/#setting-up-intellij-idea","text":"As mentioned earlier, the program I will be using is IntelliJ IDEA. Here are some video tutorials on how to install IntelliJ IDEA in your machine.","title":"Setting Up IntelliJ IDEA"},{"location":"lab00/#how-to-install-intellij-in-windows","text":"","title":"How to Install IntelliJ in Windows"},{"location":"lab00/#how-to-install-intellij-in-macos","text":"","title":"How to Install IntelliJ in macOS"},{"location":"lab00/#how-to-install-intellij-in-linux","text":"Upon installing IntelliJ IDEA in your machine, there are a few configurations you will need to carry out before starting to use IntelliJ IDEA. The following video tutorial will help you get to speed in setting up IntelliJ IDEA before starting to program.","title":"How to Install IntelliJ in Linux"},{"location":"lab00/#intellij-configuration-on-mac-linux-and-windows","text":"","title":"IntelliJ Configuration on Mac, Linux and Windows"},{"location":"lab00/#testing-intellij-idea","text":"Create different Java files to contain each of the following code snippets. Ensure that the code runs properly.","title":"Testing IntelliJ IDEA"},{"location":"lab00/#demo1","text":"Demo1.java 1 2 3 4 5 6 7 public class Demo1 { public static void main ( String [] args ) { System . out . println ( \"Welcome \" ); System . out . println ( \"To \" ); System . out . println ( \"OOP Class\" ); } }","title":"Demo1"},{"location":"lab00/#demo2","text":"Demo2.java 1 2 3 4 5 6 public class Demo2 { public static void main ( String [] args ) { System . out . println ( \"3.5 * 4 / 2 - 2.5 is \" ); System . out . println ( 3.5 * 4 / 2 - 2.5 ); } }","title":"Demo2"},{"location":"lab01/","text":"Practical 01: Getting Started with Java This practical will serve as a starting point to getting used to programming in Java. However, all object-oriented programming concepts learnt in this module can also be applied into other object-oriented programming languages like C#, or other languages that have support for it like PHP. Java is only considered a fully object-oriented programming language that's a good starting language to use to learn such concepts. Getting Started Creating Java files To create a Java file, right-click on your src folder, and under New > , select Java Class . Feel free to name your Java class in any way you wish, but ensure that NO SPACES are used inside them. New Java Class - Type in the name of your class here. We will revisit this when we learn about Interfaces in an upcoming session. Creating Packages When creating your Java files, you can keep them directly within your src folder, or in packages. To create a package in your project folder in IntelliJ Idea, simply right-click on your src folder, and under New > , select Package . Name the package as you please, and it will now provide a separate folder that will act like a folder that is its own environment for all the Java files placed here. Main Method and Execution Upon creating your Java file, whether directly inside your src folder or within a package itself, you should see something like this: View for Java Files in Packages If your Java file is located inside a package (in this example, PackageNameHere ), there should be an extra line on top that says: package PackageNameHere ; DO NOT CHANGE YOUR CLASS NAME!! Keep the Java class name as is. The name of the Java class should always be the same as the name of your .java file \u2013 this means that if you have a .java file named Exercise01 , the name of the class should also be Exercise01 . Exercise01.java public class Exercise01 { } If you change it to something else, you will find that the program runs into some Errors during Building and Compilation of the project! Your basic Java program will typically have a main method, from which your program will begin operations from. The main method declaration is rather verbose, but each keyword used here has a meaning (more of which will make sense as upcoming lectures revolving methods and visibility are covered). Declaring the main method should be like as follows: Exercise01.java public class Exercise01 { public static void main ( String [] args ) { } } Printing in Java Printing in Java will require a line like as follows: System . out . println ( \"Hello World!\" ); Take note that there are variations of the print statement, all of which you can use are as follows: System.out.println() : Prints everything inside the parentheses, and adds an additional new-space character ( \\n ) automatically System.out.print() : Prints everything inside the parentheses without any additional characters appended to the back System.out.printf() : Prints everything with the same convention as a printf() statement from the C language, without any additional characters appended to the back Retrieving User Input in Java Retrieving user input in Java will require use of the Scanner object. You can declare a standard Scanner object at the beginning of the main method like as follows: Example01.java public class Example01 { public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); } } Here, we name our Scanner object as input . However you wish to name it is not set in stone, but given proper naming conventions, one should name all objects (and by extension, your class name as well) with the Pascal Naming Convention . Notice that IntelliJ Idea may include an import statement before your class declaration statement (if not, you should manually include this yourself): Example01.java import java.util.Scanner ; public class Example01 { public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); } } Essentially, the Scanner library class should be imported in order to make use fo it in your program. This will apply to many other library classes you may end up using when using many other different functions that are not baked into Java by default. Tasks Task 1 Create a program with a new class called FirstJava which produces the following output: This is my first attempt to program in Java It works! Modify the source code such that it produces the following output: This is my first attempt to program in Java It works! Task 2 Identify and fix the errors in the following source codes. Program 1 Practical1.java 1 2 3 4 5 public class Practical1 { public static void main ( String [] args ) { System . out . println ( ' Welcome to Java ! ); } } Program 2 Test.java 1 2 3 4 5 6 7 8 9 10 public class Test { public void main ( string [] args ) { double i = 50.0 ; double k = i + 50.0 ; double j = k + 1 ; System . out . println ( \"j is \" + j + \" and k is \" + k ); } } Task 3 Copy and run the following source code. The expected output should be as follows: Modify the source code such that it computes the circumference of a circle instead. Formula: circumference = 2 * radius * pi Task 4 Write a Java program to calculate the area and perimeter of a rectangle when the user inputs the width and height using the following formula (display the output in 2 decimal places): area = width * height Task 5 Write a program that displays the current GMT time in the format hour:time:second (e.g., 1:45:19 ). Task 6 Write a program that converts pounds into kilograms. The program should prompt the user to enter a number in pounds, convert it to kilograms and display the result. Assume 1 pound is equal to 0.454 kilograms. Task 7 Write a program that converts MYR to USD. The program should prompt the user to enter a double value in MYR, convert it to USD and display the result. Look up online for the latest exchange rate and ensure the currency is displayed in 2 decimal places (as with most currency formats, this rule is a must). Task 8 Write a program that reads the subtotal and gratuity rate, then computes the gratuity and total. For example, if the user enters 10 for subtotal and 15% for gratuity rate, the program displays $1.50 as gratuity and $11.50 as the total.","title":"Practical 01: Getting Started with Java"},{"location":"lab01/#practical-01-getting-started-with-java","text":"This practical will serve as a starting point to getting used to programming in Java. However, all object-oriented programming concepts learnt in this module can also be applied into other object-oriented programming languages like C#, or other languages that have support for it like PHP. Java is only considered a fully object-oriented programming language that's a good starting language to use to learn such concepts.","title":"Practical 01: Getting Started with Java"},{"location":"lab01/#getting-started","text":"","title":"Getting Started"},{"location":"lab01/#creating-java-files","text":"To create a Java file, right-click on your src folder, and under New > , select Java Class . Feel free to name your Java class in any way you wish, but ensure that NO SPACES are used inside them. New Java Class - Type in the name of your class here. We will revisit this when we learn about Interfaces in an upcoming session.","title":"Creating Java files"},{"location":"lab01/#creating-packages","text":"When creating your Java files, you can keep them directly within your src folder, or in packages. To create a package in your project folder in IntelliJ Idea, simply right-click on your src folder, and under New > , select Package . Name the package as you please, and it will now provide a separate folder that will act like a folder that is its own environment for all the Java files placed here.","title":"Creating Packages"},{"location":"lab01/#main-method-and-execution","text":"Upon creating your Java file, whether directly inside your src folder or within a package itself, you should see something like this: View for Java Files in Packages If your Java file is located inside a package (in this example, PackageNameHere ), there should be an extra line on top that says: package PackageNameHere ; DO NOT CHANGE YOUR CLASS NAME!! Keep the Java class name as is. The name of the Java class should always be the same as the name of your .java file \u2013 this means that if you have a .java file named Exercise01 , the name of the class should also be Exercise01 . Exercise01.java public class Exercise01 { } If you change it to something else, you will find that the program runs into some Errors during Building and Compilation of the project! Your basic Java program will typically have a main method, from which your program will begin operations from. The main method declaration is rather verbose, but each keyword used here has a meaning (more of which will make sense as upcoming lectures revolving methods and visibility are covered). Declaring the main method should be like as follows: Exercise01.java public class Exercise01 { public static void main ( String [] args ) { } }","title":"Main Method and Execution"},{"location":"lab01/#printing-in-java","text":"Printing in Java will require a line like as follows: System . out . println ( \"Hello World!\" ); Take note that there are variations of the print statement, all of which you can use are as follows: System.out.println() : Prints everything inside the parentheses, and adds an additional new-space character ( \\n ) automatically System.out.print() : Prints everything inside the parentheses without any additional characters appended to the back System.out.printf() : Prints everything with the same convention as a printf() statement from the C language, without any additional characters appended to the back","title":"Printing in Java"},{"location":"lab01/#retrieving-user-input-in-java","text":"Retrieving user input in Java will require use of the Scanner object. You can declare a standard Scanner object at the beginning of the main method like as follows: Example01.java public class Example01 { public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); } } Here, we name our Scanner object as input . However you wish to name it is not set in stone, but given proper naming conventions, one should name all objects (and by extension, your class name as well) with the Pascal Naming Convention . Notice that IntelliJ Idea may include an import statement before your class declaration statement (if not, you should manually include this yourself): Example01.java import java.util.Scanner ; public class Example01 { public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); } } Essentially, the Scanner library class should be imported in order to make use fo it in your program. This will apply to many other library classes you may end up using when using many other different functions that are not baked into Java by default.","title":"Retrieving User Input in Java"},{"location":"lab01/#tasks","text":"","title":"Tasks"},{"location":"lab01/#task-1","text":"Create a program with a new class called FirstJava which produces the following output: This is my first attempt to program in Java It works! Modify the source code such that it produces the following output: This is my first attempt to program in Java It works!","title":"Task 1"},{"location":"lab01/#task-2","text":"Identify and fix the errors in the following source codes.","title":"Task 2"},{"location":"lab01/#program-1","text":"Practical1.java 1 2 3 4 5 public class Practical1 { public static void main ( String [] args ) { System . out . println ( ' Welcome to Java ! ); } }","title":"Program 1"},{"location":"lab01/#program-2","text":"Test.java 1 2 3 4 5 6 7 8 9 10 public class Test { public void main ( string [] args ) { double i = 50.0 ; double k = i + 50.0 ; double j = k + 1 ; System . out . println ( \"j is \" + j + \" and k is \" + k ); } }","title":"Program 2"},{"location":"lab01/#task-3","text":"Copy and run the following source code. The expected output should be as follows: Modify the source code such that it computes the circumference of a circle instead. Formula: circumference = 2 * radius * pi","title":"Task 3"},{"location":"lab01/#task-4","text":"Write a Java program to calculate the area and perimeter of a rectangle when the user inputs the width and height using the following formula (display the output in 2 decimal places): area = width * height","title":"Task 4"},{"location":"lab01/#task-5","text":"Write a program that displays the current GMT time in the format hour:time:second (e.g., 1:45:19 ).","title":"Task 5"},{"location":"lab01/#task-6","text":"Write a program that converts pounds into kilograms. The program should prompt the user to enter a number in pounds, convert it to kilograms and display the result. Assume 1 pound is equal to 0.454 kilograms.","title":"Task 6"},{"location":"lab01/#task-7","text":"Write a program that converts MYR to USD. The program should prompt the user to enter a double value in MYR, convert it to USD and display the result. Look up online for the latest exchange rate and ensure the currency is displayed in 2 decimal places (as with most currency formats, this rule is a must).","title":"Task 7"},{"location":"lab01/#task-8","text":"Write a program that reads the subtotal and gratuity rate, then computes the gratuity and total. For example, if the user enters 10 for subtotal and 15% for gratuity rate, the program displays $1.50 as gratuity and $11.50 as the total.","title":"Task 8"},{"location":"lab02/","text":"Practical 02: Selection Statements We will now proceed with implementing selection statements in this practical. Selection statements in Java include the if-else statement, and the switch statement. Tasks Task 1 Write a lottery program that randomly generates a two-digit number (10-99), prompts the user to enter another two-digit number (also 10-99), and determines what the user wins according to the following rules: If the user input exactly matches the randomly generated lottery number, the reward is $10,000. If the user input has both numbers used in the generated lottery number, the reward is $3,000. If any one of the digits in the user input matches one of the digits used in the generated lottery number, the reward is $1,000. Give no reward otherwise. Task 2 Write a program that prompts the user to enter a year and display the Chinese zodiac animal that corresponds with the given remainder after dividing by 12: Remainder Chinese Zodiac Animal Remainder Chinese Zodiac Animal 0 Monkey 6 Tiger 1 Rooster 7 Rabbit 2 Dog 8 Dragon 3 Pig 9 Snake 4 Rat 10 Horse 5 Ox 11 Sheep Task 3 The Body Mass Index (BMI) is a measure of health on weight. A person's BMI is calculated by taking the person's weight (in kilograms) divided by the person's height squared (height in meters). Create a BMI program that takes in both a person's weight and height as values to interpret the person's BMI. The respective BMI interpretations are as follows: BMI Interpretation BMI < 18.5 Underweight 18.5 \u2264 BMI < 25.0 Normal 25.0 \u2264 BMI < 30.0 Overweight BMI \u2265 30.0 Obese Task 4 The personal income tax is calculated based on the filing status and taxable income. There are four filing statuses: single filers, married filing jointly, married filing separately, and head of household. The tax rates are as shown below. Create a program that prompts users to input their filing status and taxable income to calculate the required tax payment for the year. Task 5 Write a program to calculate the electricity bill with the rates as follows: Consumed Units Rate ($) 1-50 1.15 51-100 2.60 101-150 3.55 151-200 4.50 201-300 5.90 301-400 6.90 401-500 7.90 501-1000 8.90 >1000 10.99 Sample Output: Enter Previous Month Reading: 180 Enter Current Month Reading: 275 Total Units Consumed: 95 Total Bill: $174.50 Hint (50 * 1.15) + (45 * 2.60)","title":"Practical 02: Selection Statements"},{"location":"lab02/#practical-02-selection-statements","text":"We will now proceed with implementing selection statements in this practical. Selection statements in Java include the if-else statement, and the switch statement.","title":"Practical 02: Selection Statements"},{"location":"lab02/#tasks","text":"","title":"Tasks"},{"location":"lab02/#task-1","text":"Write a lottery program that randomly generates a two-digit number (10-99), prompts the user to enter another two-digit number (also 10-99), and determines what the user wins according to the following rules: If the user input exactly matches the randomly generated lottery number, the reward is $10,000. If the user input has both numbers used in the generated lottery number, the reward is $3,000. If any one of the digits in the user input matches one of the digits used in the generated lottery number, the reward is $1,000. Give no reward otherwise.","title":"Task 1"},{"location":"lab02/#task-2","text":"Write a program that prompts the user to enter a year and display the Chinese zodiac animal that corresponds with the given remainder after dividing by 12: Remainder Chinese Zodiac Animal Remainder Chinese Zodiac Animal 0 Monkey 6 Tiger 1 Rooster 7 Rabbit 2 Dog 8 Dragon 3 Pig 9 Snake 4 Rat 10 Horse 5 Ox 11 Sheep","title":"Task 2"},{"location":"lab02/#task-3","text":"The Body Mass Index (BMI) is a measure of health on weight. A person's BMI is calculated by taking the person's weight (in kilograms) divided by the person's height squared (height in meters). Create a BMI program that takes in both a person's weight and height as values to interpret the person's BMI. The respective BMI interpretations are as follows: BMI Interpretation BMI < 18.5 Underweight 18.5 \u2264 BMI < 25.0 Normal 25.0 \u2264 BMI < 30.0 Overweight BMI \u2265 30.0 Obese","title":"Task 3"},{"location":"lab02/#task-4","text":"The personal income tax is calculated based on the filing status and taxable income. There are four filing statuses: single filers, married filing jointly, married filing separately, and head of household. The tax rates are as shown below. Create a program that prompts users to input their filing status and taxable income to calculate the required tax payment for the year.","title":"Task 4"},{"location":"lab02/#task-5","text":"Write a program to calculate the electricity bill with the rates as follows: Consumed Units Rate ($) 1-50 1.15 51-100 2.60 101-150 3.55 151-200 4.50 201-300 5.90 301-400 6.90 401-500 7.90 501-1000 8.90 >1000 10.99 Sample Output: Enter Previous Month Reading: 180 Enter Current Month Reading: 275 Total Units Consumed: 95 Total Bill: $174.50 Hint (50 * 1.15) + (45 * 2.60)","title":"Task 5"},{"location":"lab03/","text":"Practical 03: Loop Statements Loop structures make up the remaining part of program control structures. We will be implementing loop structures (i.e., for loop, while loop, do-while loop) in this practical. Activity: for Loops vs. while Loops vs. do-while Loops The following shows a for loop which iterates from 0 to 7, adding each iterated number into a variable called sum . int sum = 0 ; for ( int i = 0 ; i <= 7 ; i ++ ) { sum = sum + i ; } Add a line within the loop to print out the value of sum during each iteration. Convert the given for loop into a while loop and do-while loop. Is there a difference in terms of output between these two loop types? Convert the following for loop into a while loop and do-while loop. Is there a difference in terms of output between these two loop types? int sum = 0 ; for ( int i = 7 ; i < 7 ; i ++ ) { sum = sum + i ; System . out . println ( \"Value of sum: \" + sum ); } Tasks Task 1 Suppose that the tuition fees for a university program is $10,000 this year. It is expected that the tuition fees increase by 7% per year. Write a program that will estimate how long (in years) it will take for the tuition fees amount to be double of this year's amount. Task 2 Every day, a weather station receives 5 temperatures expressed in degrees Farenheit. Write a program that will accept 5 Farenheit temperatures, and display the temperature expressed in Celsius on screen. After 5 temperatures have been processed, output the message \"All Temperatures Processed\". Conversion Formula: Celsius = (Farenheit - 32) * 5 / 9 Sample Output: Farenheit Temperature #1: 67 67.00 degrees Farenheit is 19.44 degrees Celsius. Farenheit Temperature #2: 89 89.00 degrees Farenheit is 31.67 degrees Celsius. Farenheit Temperature #3: 34 34.00 degrees Farenheit is 1.11 degrees Celsius. Farenheit Temperature #2: 67 67.00 degrees Farenheit is 19.44 degrees Celsius. Farenheit Temperature #5: 34 34.00 degrees Farenheit is 1.1 degrees Celsius. All Temperatures Processed Task 3 Write a program that prompts the user to enter a 3-digit integer and determines whether it is a palindrome integer. An integer is a palindrome if it reads the same from right to left and left to right. A negative integer is treated the same as a positive integer. Here are sample runs of this program: Challenge Modify the program to check for 4-digit palindromes. Task 4 Write a program that displays the first 50 prime numbers in five lines, each of which contains 10 numbers. An integer greater than 1 is prime if its only positive divisor is 1 or itself. For example, 2, 3, 5 and 7 are prime numbers, but 4, 6, 8 and 9 are not. Hint For each number (2, 3, 4, ...), determine whether a given number is prime. The shortcut is to see if the current number is divsible by any number up to half its value. Once a prime number is found, print out the prime number followed by a space. // ... for ( int divisor = 2 ; divisor < ( iter / 2 ); divisor ++ ) { // shortcut is in here // if current number in iteration is divisible by divisor that's not 1 or the same number as itself if ( iter % divisor == 0 ) { isPrime = false ; break ; } } // ... Have a counter value that counts up to 50 each time a prime number is found. When the counter hits a multiple of 10, print a newline character. When the counter value hits 50, stop the program. Task 5 Write a program that reads an integer between 0 and 1000 and adds all the digits in the integer. For example, if an integer is 932, the sum of all digits is 14. Sample output: Enter a number between 0 and 1000: 999 The sum of digits is 27. Hint Use the % operator to extract digits and use the / operator to remove the extracted digit. For instance, 932 % 10 = 2 and 932 / 10 = 93 . Task 6 Construct a calculator program that takes in 2 integer variables and performs one of the following mathematical operations by choice: addition, subtraction, multiplication, division, and modulo (the remainder function). Include a selection menu to prompt the user to select the desired mathematical operation.","title":"Practical 03: Loop Statements"},{"location":"lab03/#practical-03-loop-statements","text":"Loop structures make up the remaining part of program control structures. We will be implementing loop structures (i.e., for loop, while loop, do-while loop) in this practical.","title":"Practical 03: Loop Statements"},{"location":"lab03/#activity-for-loops-vs-while-loops-vs-do-while-loops","text":"The following shows a for loop which iterates from 0 to 7, adding each iterated number into a variable called sum . int sum = 0 ; for ( int i = 0 ; i <= 7 ; i ++ ) { sum = sum + i ; } Add a line within the loop to print out the value of sum during each iteration. Convert the given for loop into a while loop and do-while loop. Is there a difference in terms of output between these two loop types? Convert the following for loop into a while loop and do-while loop. Is there a difference in terms of output between these two loop types? int sum = 0 ; for ( int i = 7 ; i < 7 ; i ++ ) { sum = sum + i ; System . out . println ( \"Value of sum: \" + sum ); }","title":"Activity: for Loops vs. while Loops vs. do-while Loops"},{"location":"lab03/#tasks","text":"","title":"Tasks"},{"location":"lab03/#task-1","text":"Suppose that the tuition fees for a university program is $10,000 this year. It is expected that the tuition fees increase by 7% per year. Write a program that will estimate how long (in years) it will take for the tuition fees amount to be double of this year's amount.","title":"Task 1"},{"location":"lab03/#task-2","text":"Every day, a weather station receives 5 temperatures expressed in degrees Farenheit. Write a program that will accept 5 Farenheit temperatures, and display the temperature expressed in Celsius on screen. After 5 temperatures have been processed, output the message \"All Temperatures Processed\". Conversion Formula: Celsius = (Farenheit - 32) * 5 / 9 Sample Output: Farenheit Temperature #1: 67 67.00 degrees Farenheit is 19.44 degrees Celsius. Farenheit Temperature #2: 89 89.00 degrees Farenheit is 31.67 degrees Celsius. Farenheit Temperature #3: 34 34.00 degrees Farenheit is 1.11 degrees Celsius. Farenheit Temperature #2: 67 67.00 degrees Farenheit is 19.44 degrees Celsius. Farenheit Temperature #5: 34 34.00 degrees Farenheit is 1.1 degrees Celsius. All Temperatures Processed","title":"Task 2"},{"location":"lab03/#task-3","text":"Write a program that prompts the user to enter a 3-digit integer and determines whether it is a palindrome integer. An integer is a palindrome if it reads the same from right to left and left to right. A negative integer is treated the same as a positive integer. Here are sample runs of this program:","title":"Task 3"},{"location":"lab03/#challenge","text":"Modify the program to check for 4-digit palindromes.","title":"Challenge"},{"location":"lab03/#task-4","text":"Write a program that displays the first 50 prime numbers in five lines, each of which contains 10 numbers. An integer greater than 1 is prime if its only positive divisor is 1 or itself. For example, 2, 3, 5 and 7 are prime numbers, but 4, 6, 8 and 9 are not. Hint For each number (2, 3, 4, ...), determine whether a given number is prime. The shortcut is to see if the current number is divsible by any number up to half its value. Once a prime number is found, print out the prime number followed by a space. // ... for ( int divisor = 2 ; divisor < ( iter / 2 ); divisor ++ ) { // shortcut is in here // if current number in iteration is divisible by divisor that's not 1 or the same number as itself if ( iter % divisor == 0 ) { isPrime = false ; break ; } } // ... Have a counter value that counts up to 50 each time a prime number is found. When the counter hits a multiple of 10, print a newline character. When the counter value hits 50, stop the program.","title":"Task 4"},{"location":"lab03/#task-5","text":"Write a program that reads an integer between 0 and 1000 and adds all the digits in the integer. For example, if an integer is 932, the sum of all digits is 14. Sample output: Enter a number between 0 and 1000: 999 The sum of digits is 27. Hint Use the % operator to extract digits and use the / operator to remove the extracted digit. For instance, 932 % 10 = 2 and 932 / 10 = 93 .","title":"Task 5"},{"location":"lab03/#task-6","text":"Construct a calculator program that takes in 2 integer variables and performs one of the following mathematical operations by choice: addition, subtraction, multiplication, division, and modulo (the remainder function). Include a selection menu to prompt the user to select the desired mathematical operation.","title":"Task 6"},{"location":"lab04/","text":"Practical 04: Arrays and ArrayLists Arrays allow for storing a series of values within one data structure. We will be working on implementing solutions that involve the use of arrays and ArrayList data structures in this practical. Tasks Task 1 Write a Java program that prompts for 10 integers. Print all the elements of the array in a single row, separated by spaces. Count and total up the negative numbers from the input. Count and total up the positive numbers from the input. Task 2 Write a Java program that prints the index of the smallest element in an array of integers. Sample arrays: [6, 33, 3, 63, 25, 1, 99] will return index 5 [10, -3, 55, -10, -24, 54, 0, -21, 8] will return index 4 Randomly generate 10 numbers between 0 and 100 for the first array. For the second array, randomly generate 10 numbers between -100 and 100. Task 3 Suppose the weekly hours for all employees are stored in a two-dimensional array. Each row records an employee's seven-day work hours with seven columns. For example, the following array stores the work hours for eight employees. Write a program that displays employees and their total hours worked. Initialize the array with the values shown in the following table. Sun Mon Tues Wed Thur Fri Sat Employee 0 2 4 3 4 5 8 8 Employee 1 7 3 4 3 3 4 4 Employee 2 3 3 4 3 3 2 2 Employee 3 9 3 4 7 3 4 1 Employee 4 3 5 4 3 6 3 8 Employee 5 3 4 4 6 3 4 4 Employee 6 3 7 4 8 3 8 4 Employee 7 6 3 5 9 2 7 9 Sample Output: The total working hours in a week for Employee 0 is 34 hours Employee 1 is 28 hours Employee 2 is 20 hours Employee 3 is 31 hours Employee 4 is 32 hours Employee 5 is 28 hours Employee 6 is 37 hours Employee 7 is 41 hours Note Syntax for declaring and creating 2-dimensional arrays: dataType[][] variableName = new dataType[x][y]; Task 4 Write a Java program that reads an unspecified number of scores and determines how many scores are above or equal to the average and how many scores are below the average. Enter a negative number to signify the end of the input. Assume that the maximum number of scores that can be input is 10. Sample Output: Enter the scores (negative number to end) Score 1: 10 Score 2: 10 Score 3: 6 Score 4: 6 Score 5: 2 Score 6: -1 Results ======= Average is 6.8 Number of scores above or equal to the average is 2 NUmber of scores below the average is 3 Process completed. Extra Activity: Bubble Sort Write a program that sorts an array of integers using bubble sort. Bubble sort works by swapping adjacent elements if they are not in the desired order. This process repeats from the beginning of the array until all elements are in order. Here are the steps for sorting an array of numbers from smallest to largest: FIRST ITERATION 4 2 1 5 3 : The first two elements are in the wrong order (i.e., 4 > 2), so we swap them. 2 4 1 5 3 : The second two elements are in the wrong order (i.e., 4 > 1) \u2192 swap. 2 1 4 5 3 : These two elements are in the right order (i.e., 4 < 5) \u2192 do nothing. 2 1 4 5 3 : Swap. 2 1 4 3 5 : Resulting array after first iteration. SECOND ITERATION 2 1 4 3 5 : Wrong order (i.e., 2 > 1) \u2192 swap. 1 2 4 3 5 : Right order (i.e., 2 < 4) \u2192 do nothing. 1 2 4 3 5 : Wrong order (i.e., 4 > 3) \u2192 swap. 1 2 3 4 5 : Resulting array after first iteration. THIRD ITERATION 1 2 3 4 5 : Right order (i.e., 1 < 2) \u2192 do nothing. 1 2 3 4 5 : Right order (i.e., 2 < 3) \u2192 do nothing. 1 2 3 4 5 : Resulting array after first iteration. You may try out your algorithm with the following sample arrays: [6, 32, 7, 2, 99, 31, 53] [-1, -23, -5, -75, -21, -43, -15] [6, 21, -43, 12, 75, -32, -6] Array of 10 randomly generated numbers (between 0 and 100) You can view the video tutorial as shown below to gain a better understanding behind how it works.","title":"Practical 04: Arrays and ArrayLists"},{"location":"lab04/#practical-04-arrays-and-arraylists","text":"Arrays allow for storing a series of values within one data structure. We will be working on implementing solutions that involve the use of arrays and ArrayList data structures in this practical.","title":"Practical 04: Arrays and ArrayLists"},{"location":"lab04/#tasks","text":"","title":"Tasks"},{"location":"lab04/#task-1","text":"Write a Java program that prompts for 10 integers. Print all the elements of the array in a single row, separated by spaces. Count and total up the negative numbers from the input. Count and total up the positive numbers from the input.","title":"Task 1"},{"location":"lab04/#task-2","text":"Write a Java program that prints the index of the smallest element in an array of integers. Sample arrays: [6, 33, 3, 63, 25, 1, 99] will return index 5 [10, -3, 55, -10, -24, 54, 0, -21, 8] will return index 4 Randomly generate 10 numbers between 0 and 100 for the first array. For the second array, randomly generate 10 numbers between -100 and 100.","title":"Task 2"},{"location":"lab04/#task-3","text":"Suppose the weekly hours for all employees are stored in a two-dimensional array. Each row records an employee's seven-day work hours with seven columns. For example, the following array stores the work hours for eight employees. Write a program that displays employees and their total hours worked. Initialize the array with the values shown in the following table. Sun Mon Tues Wed Thur Fri Sat Employee 0 2 4 3 4 5 8 8 Employee 1 7 3 4 3 3 4 4 Employee 2 3 3 4 3 3 2 2 Employee 3 9 3 4 7 3 4 1 Employee 4 3 5 4 3 6 3 8 Employee 5 3 4 4 6 3 4 4 Employee 6 3 7 4 8 3 8 4 Employee 7 6 3 5 9 2 7 9 Sample Output: The total working hours in a week for Employee 0 is 34 hours Employee 1 is 28 hours Employee 2 is 20 hours Employee 3 is 31 hours Employee 4 is 32 hours Employee 5 is 28 hours Employee 6 is 37 hours Employee 7 is 41 hours Note Syntax for declaring and creating 2-dimensional arrays: dataType[][] variableName = new dataType[x][y];","title":"Task 3"},{"location":"lab04/#task-4","text":"Write a Java program that reads an unspecified number of scores and determines how many scores are above or equal to the average and how many scores are below the average. Enter a negative number to signify the end of the input. Assume that the maximum number of scores that can be input is 10. Sample Output: Enter the scores (negative number to end) Score 1: 10 Score 2: 10 Score 3: 6 Score 4: 6 Score 5: 2 Score 6: -1 Results ======= Average is 6.8 Number of scores above or equal to the average is 2 NUmber of scores below the average is 3 Process completed.","title":"Task 4"},{"location":"lab04/#extra-activity-bubble-sort","text":"Write a program that sorts an array of integers using bubble sort. Bubble sort works by swapping adjacent elements if they are not in the desired order. This process repeats from the beginning of the array until all elements are in order. Here are the steps for sorting an array of numbers from smallest to largest: FIRST ITERATION 4 2 1 5 3 : The first two elements are in the wrong order (i.e., 4 > 2), so we swap them. 2 4 1 5 3 : The second two elements are in the wrong order (i.e., 4 > 1) \u2192 swap. 2 1 4 5 3 : These two elements are in the right order (i.e., 4 < 5) \u2192 do nothing. 2 1 4 5 3 : Swap. 2 1 4 3 5 : Resulting array after first iteration. SECOND ITERATION 2 1 4 3 5 : Wrong order (i.e., 2 > 1) \u2192 swap. 1 2 4 3 5 : Right order (i.e., 2 < 4) \u2192 do nothing. 1 2 4 3 5 : Wrong order (i.e., 4 > 3) \u2192 swap. 1 2 3 4 5 : Resulting array after first iteration. THIRD ITERATION 1 2 3 4 5 : Right order (i.e., 1 < 2) \u2192 do nothing. 1 2 3 4 5 : Right order (i.e., 2 < 3) \u2192 do nothing. 1 2 3 4 5 : Resulting array after first iteration. You may try out your algorithm with the following sample arrays: [6, 32, 7, 2, 99, 31, 53] [-1, -23, -5, -75, -21, -43, -15] [6, 21, -43, 12, 75, -32, -6] Array of 10 randomly generated numbers (between 0 and 100) You can view the video tutorial as shown below to gain a better understanding behind how it works.","title":"Extra Activity: Bubble Sort"},{"location":"lab05/","text":"Practical 05: Methods Aside from being able to modularize code, using methods is integral to when we start covering Classes and Objects in the next session. This practical introduces use of methods that will be used alongside the main method. Functions or Methods.. what gives!? Methods and functions tend to be used interchangably (and in erroneous fashion a lot of the time); however, methods have a deeper meaning than functions. Functions are used to carry out a process that changes input into output. Whether these functions are useful in a certain context is dependent on when and/or where they are used. Within the OOP context, these functions are sometimes called methods (or operations). You can view methods as like a way how objects do things . For example, the method a person speaks involves opening their mouth and letting out their voice. Here, if you were to model a person as a class, this class would have a speaking function that's referred as a method. In this case, unlike functions, methods are meant to have meaningful purposes. Bottom Line If a function can be attributed to an object, it's called a method. In fully object-oriented languages like in Java where everything is built in classes, all functions are called methods. More about classes and objects will be covered in the next lecture. Activity: Decomposing a Complex Program into Methods Recall the simple calculator application you created in Practical 03 Task 6. The prepared solution can be split into several methods carrying out different purposes. Obtaining the option to choose the type of arithmetic operation to be carried out Obtaining user input of two integer values Displaying results from user inputs Consider each of the following methods and determine what return type best fits the solution at hand. Method 1: Choosing Arithmetic Operation The discussed solution involved obtaining an option with the use of a while loop like as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Scanner input = new Scanner ( System . in ); int option = 0 ; do { if ( option == 0 ) { System . out . println ( \"1.\\tAddition\" ); System . out . println ( \"2.\\tSubtraction\" ); System . out . println ( \"3.\\tMultiplication\" ); System . out . println ( \"4.\\tDivision\" ); System . out . println ( \"5.\\tModulo (Remainder)\" ); } System . out . print ( \"Enter operation >> \" ); option = input . nextInt (); if ( option < 0 || option > 5 ) System . out . println ( \"Invalid option, try again!\\n\" ); } while ( option < 0 || option > 5 ); Let's encapsulate this part of the solution into a method called selectOperation . The end result is the integer variable option . Therefore, we use the int return type for the method. At the end of this method, we ought to put in a return statement to return option back to the method that called it in the first place. In this case, it would be the main method. selectOperation() should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private static int selectOperation () { // this is going to cause a problem we'll solve later Scanner input = new Scanner ( System . in ); int option = 0 ; do { if ( option == 0 ) { System . out . println ( \"1.\\tAddition\" ); System . out . println ( \"2.\\tSubtraction\" ); System . out . println ( \"3.\\tMultiplication\" ); System . out . println ( \"4.\\tDivision\" ); System . out . println ( \"5.\\tModulo (Remainder)\" ); } System . out . print ( \"Enter operation >> \" ); option = input . nextInt (); if ( option < 0 || option > 5 ) System . out . println ( \"Invalid option, try again!\\n\" ); } while ( option < 0 || option > 5 ); return option ; } Notice that we also added the private and static keywords in front of the method declaration. The use of the private keyword makes a method or variable such that it's only accessible within the class itself. As for the static keyword, for the time being just know that you'll need to use static whenever you're linking methods in a class where a main method is involved. In the main method, enter this in place of the code you just moved into the newly created method. This will retrieve the returned value from the selectOperation() method and keep it in a local variable called option . public static void main ( String [] args ) { int option = selectOperation (); /* ... */ } Method 2: User Input of 2 Integer Values This method should retrieve 2 values as according to the code snippet below: System . out . println ( \"Enter integer #1 >> \" ); int num1 = input . nextInt (); System . out . println ( \"Enter integer #2 >> \" ); int num2 = input . nextInt (); Let's name the method containing this code snippet getUserInput() . Apart from using primitive data types, one can also return arrays of such data types from a method. We can combine these two numbers into an integer array like as follows: 1 2 3 4 5 6 7 8 9 10 11 12 private static int [] getUserInput () { System . out . println ( \"Enter integer #1 >> \" ); int num1 = input . nextInt (); System . out . println ( \"Enter integer #2 >> \" ); int num2 = input . nextInt (); // create an integer array to contain both user inputs int results [] = { num1 , num2 }; return results ; } Here, we are assuming that the first value entered corresponds to results[0] and the second value corresponds to results[1] . Like the previous method, let's call the getUserInput() method from the main method and save the array in a local array variable in the main method. public static void main ( String [] args ) { int option = selectOperation (); int [] userInput = getUserInput (); /* ... */ } However, note that we do not have a Scanner object (let alone one called input ) in this method. That Scanner object now belongs to the selectOperation() method. If you run the program now, it will throw an exception stating something along the lines of input being non-existent within this newly created method. In order to fix this, we will make the Scanner object global within the class. Remove the Scanner object declaration from selectOperation() and redeclare it as follows at the beginning right after the class declaration: MethodExample.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class MethodExample { private static Scanner input = new Scanner ( System . in ); private static int selectOperation () { /* ... */ } private static int [] getUserInput () { /* ... */ } public static void main ( String [] args ) { int operation = selectOperation (); int [] userInput = getUserInput (); /* ... */ } } Method 3: Displaying Results Now all that's left is to print out the results from the switch statement. The code snippet from the discussed solution is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 switch ( option ) { case 1 : System . out . println ( num1 + \" + \" + num2 + \" = \" + ( num1 + num2 )); break ; case 2 : System . out . println ( num1 + \" - \" + num2 + \" = \" + ( num1 - num2 )); break ; case 3 : System . out . println ( num1 + \" * \" + num2 + \" = \" + ( num1 * num2 )); break ; case 4 : System . out . println ( num1 + \" / \" + num2 + \" = \" + ( num1 / num2 )); break ; case 5 : System . out . println ( num1 + \" mod \" + num2 + \" = \" + ( num1 % num2 )); break ; default : } Here, we are only printing statements; printing statements do not constitute as returning anything to the method that called it in the first place. Since we are not expecting to returning any value at all, this new method we call printResults() will have a void return type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static void printResults ( int option , int num1 , int num2 ) { switch ( option ) { case 1 : System . out . println ( num1 + \" + \" + num2 + \" = \" + ( num1 + num2 )); break ; case 2 : System . out . println ( num1 + \" - \" + num2 + \" = \" + ( num1 - num2 )); break ; case 3 : System . out . println ( num1 + \" * \" + num2 + \" = \" + ( num1 * num2 )); break ; case 4 : System . out . println ( num1 + \" / \" + num2 + \" = \" + ( num1 / num2 )); break ; case 5 : System . out . println ( num1 + \" mod \" + num2 + \" = \" + ( num1 % num2 )); break ; default : } } Note here that this time, we are passing parameters into this method. This is because unlike the last 2 methods which did not require any input from the method that called it, this method requires those 3 variables in order to function. This method is assuming that the first value is to be regarded as the operator option selected, followed by the first and second input numbers from the user respectively. There is no set rule as to when and where a method should require parameters. Whether or not a method should require parameter(s), in the declaration, how many of them are required, and/or consequently return value(s) is dependent on how you design your solution. In this case, since printResults() does not return any value to the method that called it, we do not need to store anything into a local variable. In the main method, invoke this method as is without equating it to a local variable like as follows. However, since it requires 3 parameters for it to work, when invoking the method you will need to enter the required values (being option and userInput ). 1 2 3 4 5 6 7 public static void main ( String [] args ) { int option = selectOperation (); int [] userInput = getUserInput (); printResults ( option , userInput [ 0 ] , userInput [ 1 ] ); } Putting them altogether And voila, you now have a solution that's more modular by splitting a working solution into 3 different methods that work separately from each other. The main method is now relegated to only invoking methods as and when they are needed. Tasks Task 1 Write a method that computes the multiplication of the digits in an integer. Use the following method header: public static int mulDigit ( int n ) For example, mulDigit(234) returns 24 (i.e., \\(2 \\times 3 \\times 4\\) ). Hint Use the % operator to extract digits, and the / operator to remove the extracted digit. For instance, to extract 4 from 234, use 234 % 10 (= 4). To remove 4 from 234, use 234 / 10 (= 23). Use a loop to repeatedly extract and remove the digit until all the digits are extracted. Write a test program that prompts the user to enter an integer and displays the multiplication of all its digits. Write a test program that prompts the user to enter an integer, then displays the result of all its digits multiplied together randomly generates a number ranging between (and inclusive of) 100 and 10,000, then displays the result of all its digits multiplied together Task 2 Create a class called PrimeNumber which contains 3 methods: isPrimeNumber(int num) This will return true if num is prime, and false otherwise. getListOfPrimeNumbers(int start, int end) This will return the list of prime numbers between the start and end number. getDivisible(int num) This will return the list of divisible numbers for the provided number. Task 3 Write a method that converts a hexadecimal number into a decimal number. For example, ABCD 16 is calculated as \\[ = A \\times 16^3 + B \\times 16^2 + C \\times 16^1 + D \\times 16^0 = 43981 \\] You may use the following reference: Hexadecimal 0 1 2 3 4 5 6 7 8 9 A B C D E F Decimal 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Once you have completed your method, you can verify your result by calling the following function: Integer . parseInt ( < number_input > , 16 ); Test your program with the following values: 2AC, AB3F, FF99 Task 4 Write a class that contains the following two methods: /* Convert miles to kilometers */ public static double mileToKilometer ( double mile ) /* Convert kilometers to miles */ public static double kilometerToMile ( double kilometer ) The formula for the conversion is: 1 mile = 1.609 kilometers Write a test program that invokes these methods when necessary after prompting to enter either a value in kilometers or miles (ask for choice first). Task 5 Write a class that contains the following two methods: /* Convert pounds to kilograms */ public static double poundToKilogram ( double pound ) /* Convert kilograms to pounds */ public static double kilogramToPound ( double kilogram ) The formula for the conversion is: \\[ pounds = 0.453 \\times kilograms \\] \\[ kilograms = 2.204 \\times pounds \\] Write a test program that invokes these methods when necessary after prompting to enter either a value in kilograms or pounds (ask for choice first). Task 6 Utilize methods to solve this multidimensional array problem. Write a program that randomly fills in 0s and 1s into a Tic-tac-toe board, prints the board, and find the rows, columns, or diagonals with all 0s or 1s. Use a two-dimensional array to represent a Tic-tac-toe board. Hint Use Math.random() * 2 to randomly generate the 0s and 1s. Here are some sample runs of the program: TicTacToe board: 0 1 0 1 1 1 1 1 0 Result(s): All 1's on row 1 All 1's on column 1 TicTacToe board: 0 1 1 0 0 0 0 0 1 Result(s): All 0's on row 1 All 0's on column 0 TicTacToe board: 0 1 0 1 0 1 0 0 1 Result(s): All 0's on subdiagonal TicTacToe board: 1 1 1 0 1 0 1 1 1 Result(s): All 1's on row 0 All 1's on row 2 All 1's on column 1 All 1's on major diagonal All 1's on subdiagonal","title":"Practical 05: Methods"},{"location":"lab05/#practical-05-methods","text":"Aside from being able to modularize code, using methods is integral to when we start covering Classes and Objects in the next session. This practical introduces use of methods that will be used alongside the main method.","title":"Practical 05: Methods"},{"location":"lab05/#functions-or-methods-what-gives","text":"Methods and functions tend to be used interchangably (and in erroneous fashion a lot of the time); however, methods have a deeper meaning than functions. Functions are used to carry out a process that changes input into output. Whether these functions are useful in a certain context is dependent on when and/or where they are used. Within the OOP context, these functions are sometimes called methods (or operations). You can view methods as like a way how objects do things . For example, the method a person speaks involves opening their mouth and letting out their voice. Here, if you were to model a person as a class, this class would have a speaking function that's referred as a method. In this case, unlike functions, methods are meant to have meaningful purposes. Bottom Line If a function can be attributed to an object, it's called a method. In fully object-oriented languages like in Java where everything is built in classes, all functions are called methods. More about classes and objects will be covered in the next lecture.","title":"Functions or Methods.. what gives!?"},{"location":"lab05/#activity-decomposing-a-complex-program-into-methods","text":"Recall the simple calculator application you created in Practical 03 Task 6. The prepared solution can be split into several methods carrying out different purposes. Obtaining the option to choose the type of arithmetic operation to be carried out Obtaining user input of two integer values Displaying results from user inputs Consider each of the following methods and determine what return type best fits the solution at hand.","title":"Activity: Decomposing a Complex Program into Methods"},{"location":"lab05/#method-1-choosing-arithmetic-operation","text":"The discussed solution involved obtaining an option with the use of a while loop like as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Scanner input = new Scanner ( System . in ); int option = 0 ; do { if ( option == 0 ) { System . out . println ( \"1.\\tAddition\" ); System . out . println ( \"2.\\tSubtraction\" ); System . out . println ( \"3.\\tMultiplication\" ); System . out . println ( \"4.\\tDivision\" ); System . out . println ( \"5.\\tModulo (Remainder)\" ); } System . out . print ( \"Enter operation >> \" ); option = input . nextInt (); if ( option < 0 || option > 5 ) System . out . println ( \"Invalid option, try again!\\n\" ); } while ( option < 0 || option > 5 ); Let's encapsulate this part of the solution into a method called selectOperation . The end result is the integer variable option . Therefore, we use the int return type for the method. At the end of this method, we ought to put in a return statement to return option back to the method that called it in the first place. In this case, it would be the main method. selectOperation() should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private static int selectOperation () { // this is going to cause a problem we'll solve later Scanner input = new Scanner ( System . in ); int option = 0 ; do { if ( option == 0 ) { System . out . println ( \"1.\\tAddition\" ); System . out . println ( \"2.\\tSubtraction\" ); System . out . println ( \"3.\\tMultiplication\" ); System . out . println ( \"4.\\tDivision\" ); System . out . println ( \"5.\\tModulo (Remainder)\" ); } System . out . print ( \"Enter operation >> \" ); option = input . nextInt (); if ( option < 0 || option > 5 ) System . out . println ( \"Invalid option, try again!\\n\" ); } while ( option < 0 || option > 5 ); return option ; } Notice that we also added the private and static keywords in front of the method declaration. The use of the private keyword makes a method or variable such that it's only accessible within the class itself. As for the static keyword, for the time being just know that you'll need to use static whenever you're linking methods in a class where a main method is involved. In the main method, enter this in place of the code you just moved into the newly created method. This will retrieve the returned value from the selectOperation() method and keep it in a local variable called option . public static void main ( String [] args ) { int option = selectOperation (); /* ... */ }","title":"Method 1: Choosing Arithmetic Operation"},{"location":"lab05/#method-2-user-input-of-2-integer-values","text":"This method should retrieve 2 values as according to the code snippet below: System . out . println ( \"Enter integer #1 >> \" ); int num1 = input . nextInt (); System . out . println ( \"Enter integer #2 >> \" ); int num2 = input . nextInt (); Let's name the method containing this code snippet getUserInput() . Apart from using primitive data types, one can also return arrays of such data types from a method. We can combine these two numbers into an integer array like as follows: 1 2 3 4 5 6 7 8 9 10 11 12 private static int [] getUserInput () { System . out . println ( \"Enter integer #1 >> \" ); int num1 = input . nextInt (); System . out . println ( \"Enter integer #2 >> \" ); int num2 = input . nextInt (); // create an integer array to contain both user inputs int results [] = { num1 , num2 }; return results ; } Here, we are assuming that the first value entered corresponds to results[0] and the second value corresponds to results[1] . Like the previous method, let's call the getUserInput() method from the main method and save the array in a local array variable in the main method. public static void main ( String [] args ) { int option = selectOperation (); int [] userInput = getUserInput (); /* ... */ } However, note that we do not have a Scanner object (let alone one called input ) in this method. That Scanner object now belongs to the selectOperation() method. If you run the program now, it will throw an exception stating something along the lines of input being non-existent within this newly created method. In order to fix this, we will make the Scanner object global within the class. Remove the Scanner object declaration from selectOperation() and redeclare it as follows at the beginning right after the class declaration: MethodExample.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class MethodExample { private static Scanner input = new Scanner ( System . in ); private static int selectOperation () { /* ... */ } private static int [] getUserInput () { /* ... */ } public static void main ( String [] args ) { int operation = selectOperation (); int [] userInput = getUserInput (); /* ... */ } }","title":"Method 2: User Input of 2 Integer Values"},{"location":"lab05/#method-3-displaying-results","text":"Now all that's left is to print out the results from the switch statement. The code snippet from the discussed solution is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 switch ( option ) { case 1 : System . out . println ( num1 + \" + \" + num2 + \" = \" + ( num1 + num2 )); break ; case 2 : System . out . println ( num1 + \" - \" + num2 + \" = \" + ( num1 - num2 )); break ; case 3 : System . out . println ( num1 + \" * \" + num2 + \" = \" + ( num1 * num2 )); break ; case 4 : System . out . println ( num1 + \" / \" + num2 + \" = \" + ( num1 / num2 )); break ; case 5 : System . out . println ( num1 + \" mod \" + num2 + \" = \" + ( num1 % num2 )); break ; default : } Here, we are only printing statements; printing statements do not constitute as returning anything to the method that called it in the first place. Since we are not expecting to returning any value at all, this new method we call printResults() will have a void return type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static void printResults ( int option , int num1 , int num2 ) { switch ( option ) { case 1 : System . out . println ( num1 + \" + \" + num2 + \" = \" + ( num1 + num2 )); break ; case 2 : System . out . println ( num1 + \" - \" + num2 + \" = \" + ( num1 - num2 )); break ; case 3 : System . out . println ( num1 + \" * \" + num2 + \" = \" + ( num1 * num2 )); break ; case 4 : System . out . println ( num1 + \" / \" + num2 + \" = \" + ( num1 / num2 )); break ; case 5 : System . out . println ( num1 + \" mod \" + num2 + \" = \" + ( num1 % num2 )); break ; default : } } Note here that this time, we are passing parameters into this method. This is because unlike the last 2 methods which did not require any input from the method that called it, this method requires those 3 variables in order to function. This method is assuming that the first value is to be regarded as the operator option selected, followed by the first and second input numbers from the user respectively. There is no set rule as to when and where a method should require parameters. Whether or not a method should require parameter(s), in the declaration, how many of them are required, and/or consequently return value(s) is dependent on how you design your solution. In this case, since printResults() does not return any value to the method that called it, we do not need to store anything into a local variable. In the main method, invoke this method as is without equating it to a local variable like as follows. However, since it requires 3 parameters for it to work, when invoking the method you will need to enter the required values (being option and userInput ). 1 2 3 4 5 6 7 public static void main ( String [] args ) { int option = selectOperation (); int [] userInput = getUserInput (); printResults ( option , userInput [ 0 ] , userInput [ 1 ] ); }","title":"Method 3: Displaying Results"},{"location":"lab05/#putting-them-altogether","text":"And voila, you now have a solution that's more modular by splitting a working solution into 3 different methods that work separately from each other. The main method is now relegated to only invoking methods as and when they are needed.","title":"Putting them altogether"},{"location":"lab05/#tasks","text":"","title":"Tasks"},{"location":"lab05/#task-1","text":"Write a method that computes the multiplication of the digits in an integer. Use the following method header: public static int mulDigit ( int n ) For example, mulDigit(234) returns 24 (i.e., \\(2 \\times 3 \\times 4\\) ). Hint Use the % operator to extract digits, and the / operator to remove the extracted digit. For instance, to extract 4 from 234, use 234 % 10 (= 4). To remove 4 from 234, use 234 / 10 (= 23). Use a loop to repeatedly extract and remove the digit until all the digits are extracted. Write a test program that prompts the user to enter an integer and displays the multiplication of all its digits. Write a test program that prompts the user to enter an integer, then displays the result of all its digits multiplied together randomly generates a number ranging between (and inclusive of) 100 and 10,000, then displays the result of all its digits multiplied together","title":"Task 1"},{"location":"lab05/#task-2","text":"Create a class called PrimeNumber which contains 3 methods: isPrimeNumber(int num) This will return true if num is prime, and false otherwise. getListOfPrimeNumbers(int start, int end) This will return the list of prime numbers between the start and end number. getDivisible(int num) This will return the list of divisible numbers for the provided number.","title":"Task 2"},{"location":"lab05/#task-3","text":"Write a method that converts a hexadecimal number into a decimal number. For example, ABCD 16 is calculated as \\[ = A \\times 16^3 + B \\times 16^2 + C \\times 16^1 + D \\times 16^0 = 43981 \\] You may use the following reference: Hexadecimal 0 1 2 3 4 5 6 7 8 9 A B C D E F Decimal 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Once you have completed your method, you can verify your result by calling the following function: Integer . parseInt ( < number_input > , 16 ); Test your program with the following values: 2AC, AB3F, FF99","title":"Task 3"},{"location":"lab05/#task-4","text":"Write a class that contains the following two methods: /* Convert miles to kilometers */ public static double mileToKilometer ( double mile ) /* Convert kilometers to miles */ public static double kilometerToMile ( double kilometer ) The formula for the conversion is: 1 mile = 1.609 kilometers Write a test program that invokes these methods when necessary after prompting to enter either a value in kilometers or miles (ask for choice first).","title":"Task 4"},{"location":"lab05/#task-5","text":"Write a class that contains the following two methods: /* Convert pounds to kilograms */ public static double poundToKilogram ( double pound ) /* Convert kilograms to pounds */ public static double kilogramToPound ( double kilogram ) The formula for the conversion is: \\[ pounds = 0.453 \\times kilograms \\] \\[ kilograms = 2.204 \\times pounds \\] Write a test program that invokes these methods when necessary after prompting to enter either a value in kilograms or pounds (ask for choice first).","title":"Task 5"},{"location":"lab05/#task-6","text":"Utilize methods to solve this multidimensional array problem. Write a program that randomly fills in 0s and 1s into a Tic-tac-toe board, prints the board, and find the rows, columns, or diagonals with all 0s or 1s. Use a two-dimensional array to represent a Tic-tac-toe board. Hint Use Math.random() * 2 to randomly generate the 0s and 1s. Here are some sample runs of the program: TicTacToe board: 0 1 0 1 1 1 1 1 0 Result(s): All 1's on row 1 All 1's on column 1 TicTacToe board: 0 1 1 0 0 0 0 0 1 Result(s): All 0's on row 1 All 0's on column 0 TicTacToe board: 0 1 0 1 0 1 0 0 1 Result(s): All 0's on subdiagonal TicTacToe board: 1 1 1 0 1 0 1 1 1 Result(s): All 1's on row 0 All 1's on row 2 All 1's on column 1 All 1's on major diagonal All 1's on subdiagonal","title":"Task 6"},{"location":"lab06/","text":"Practical 06: Classes and Objects We will now begin to implement classes and declare them as objects in this practical session. In procedural programming, the idea is to break down problems into required actions to be taken. Here, one may associate solutions as verbs (i.e., to-do actions). Previously, we only dabbled in one class file per task solution. In those classes, we still approached our solutions in a procedural programming manner. However, in object-oriented programming, one has to decompose problems into objects (i.e., nouns). One must consider what objects are needed in order for the program to function. These objects will contain attributes and methods (i.e., their own functions) to play roles in a program. Tasks Task 1 Create a class named Household (save as Household.java ) that includes a default constructor and two data fields (number of occupants and annual income). And then, create a driver program (save as TestHousehold.java ) to test the class. Sample output for the driver program: Household 1 *********** Number of occupants: 0 Annual Income: .00 Values have been modified Number of occupants: 6 Annual Income: 25,000.00 Modify the default constructor for the Household class to set the occupants field to 1 and annual income field to 0. Then, run the driver program again. Create an additional overloaded constructor for the Household class. This constructor receives an integer argument and assigns the value to the occupant field. Change any needed statements to the driver program to ensure that the overloaded constructor works correctly. Save and test the changes made. Create a third overloaded constructor for the Household class. This constructor receives two arguments, the values of which are assigned to the occupant and income fields respectively. Add any needed statements to the driver program to ensure that the overloaded constructor works correctly. Save and test the changes made. Create a method named calcAverageIncome() (add it to the Household class) to calculate the average income for each household. The formula is as follows: Average income = annual income / number of occupants Add any needed statements to the driver program to ensure that the method works correctly. Save and test the changes made. Task 2 Define a class named Planet , which contains two instance variables that store the name of the planet ( name ) and the number of days the planet takes to travel around the Sun ( travelDays ). Write a method printPlanet() which displays the planet's details. In addition, write a test class to test your Planet class. Sample output for the driver program: Enter the planet name: Earth Enter the travel days: 365 ----------------------------- Planet Name: Earth Travel Days: 365 Add a calculateAge() method to your Planet class which calculates the person's age on that planet. Use the following formula: Age on the planet = (age * 365) / travelDays The calculateAverage() method should receive an argument that represents the age on Earth. Modify your test class to obtain user input on their age on Earth and test your calculateAge() method. Planet Travel Days Venus 255 Mercury 88 Jupiter 4380 Saturn 10767 Sample output for driver program: Enter your age on Earth: 20 Enter the planet name: Venus Enter the travel days for Venus: 255 ------------------------------------- Planet Name: Venus Travel Days: 255 Age on Venus: 28 Add the following constructors to your Planet class: A no-arg constructor to initialize the value of name to \"Earth\" and travelDays to 365. A constructor with two parameters. Modify your test class to test the constructors you have defined. Task 3 Create a class based on the following class diagram: Note: Initialize the value of type to \u201cApartment\u201d, zone to \u2018A\u2019, price to 68000.00, numberOfBedrooms to 3 and freehold to false for no-arg constructor. Use the toString() method to print out all house details. Create a driver program for the class you just created to test all the available constructors and methods. Create three house objects. Create an array to store the three house objects. Modify the House class by using the this keyword to refer to the data member(s) and constructor (if possible).","title":"Practical 06: Classes and Objects"},{"location":"lab06/#practical-06-classes-and-objects","text":"We will now begin to implement classes and declare them as objects in this practical session. In procedural programming, the idea is to break down problems into required actions to be taken. Here, one may associate solutions as verbs (i.e., to-do actions). Previously, we only dabbled in one class file per task solution. In those classes, we still approached our solutions in a procedural programming manner. However, in object-oriented programming, one has to decompose problems into objects (i.e., nouns). One must consider what objects are needed in order for the program to function. These objects will contain attributes and methods (i.e., their own functions) to play roles in a program.","title":"Practical 06: Classes and Objects"},{"location":"lab06/#tasks","text":"","title":"Tasks"},{"location":"lab06/#task-1","text":"Create a class named Household (save as Household.java ) that includes a default constructor and two data fields (number of occupants and annual income). And then, create a driver program (save as TestHousehold.java ) to test the class. Sample output for the driver program: Household 1 *********** Number of occupants: 0 Annual Income: .00 Values have been modified Number of occupants: 6 Annual Income: 25,000.00 Modify the default constructor for the Household class to set the occupants field to 1 and annual income field to 0. Then, run the driver program again. Create an additional overloaded constructor for the Household class. This constructor receives an integer argument and assigns the value to the occupant field. Change any needed statements to the driver program to ensure that the overloaded constructor works correctly. Save and test the changes made. Create a third overloaded constructor for the Household class. This constructor receives two arguments, the values of which are assigned to the occupant and income fields respectively. Add any needed statements to the driver program to ensure that the overloaded constructor works correctly. Save and test the changes made. Create a method named calcAverageIncome() (add it to the Household class) to calculate the average income for each household. The formula is as follows: Average income = annual income / number of occupants Add any needed statements to the driver program to ensure that the method works correctly. Save and test the changes made.","title":"Task 1"},{"location":"lab06/#task-2","text":"Define a class named Planet , which contains two instance variables that store the name of the planet ( name ) and the number of days the planet takes to travel around the Sun ( travelDays ). Write a method printPlanet() which displays the planet's details. In addition, write a test class to test your Planet class. Sample output for the driver program: Enter the planet name: Earth Enter the travel days: 365 ----------------------------- Planet Name: Earth Travel Days: 365 Add a calculateAge() method to your Planet class which calculates the person's age on that planet. Use the following formula: Age on the planet = (age * 365) / travelDays The calculateAverage() method should receive an argument that represents the age on Earth. Modify your test class to obtain user input on their age on Earth and test your calculateAge() method. Planet Travel Days Venus 255 Mercury 88 Jupiter 4380 Saturn 10767 Sample output for driver program: Enter your age on Earth: 20 Enter the planet name: Venus Enter the travel days for Venus: 255 ------------------------------------- Planet Name: Venus Travel Days: 255 Age on Venus: 28 Add the following constructors to your Planet class: A no-arg constructor to initialize the value of name to \"Earth\" and travelDays to 365. A constructor with two parameters. Modify your test class to test the constructors you have defined.","title":"Task 2"},{"location":"lab06/#task-3","text":"Create a class based on the following class diagram: Note: Initialize the value of type to \u201cApartment\u201d, zone to \u2018A\u2019, price to 68000.00, numberOfBedrooms to 3 and freehold to false for no-arg constructor. Use the toString() method to print out all house details. Create a driver program for the class you just created to test all the available constructors and methods. Create three house objects. Create an array to store the three house objects. Modify the House class by using the this keyword to refer to the data member(s) and constructor (if possible).","title":"Task 3"},{"location":"lab07/","text":"Practical 07: Inheritance Inheritance is one of the key concepts in object-oriented programming. With it, one can group similar elements (i.e., attributes and/or methods) of a group of classes and stash them in a superclass/parent class. The separate classes (now subclasses/child classes) will inherit these similar elements while having their own unique elements that make them different from the other fellow subclasses. Activity: Implementing \"IS-A\" Relationships Inheritance defines relationships between classes, the \"IS-A\" relationship type in particular. Illustration Example To illustrate this, let's compare two different groups of academic staff in Taylor's College, namely the full-time staff and part-time staff. Here, we are implying the following: A full-time academic staff member \" IS-A \" academic staff. A part-time academic staff member \" IS-A \" academic staff. Ignore the grammatical error, the idea's to show relations between these superclass and subclasses. \ud83d\ude1d On a base level, every academic staff has common attributes including: full name ( fullName ) staff ID ( id ) qualification level (assume 1 stands for Bachelor, 2 stands for Masters, and 3 stands for PhD) ( qualificationLevel ) Now let's compare some differences between the two types of staff: Full time academic staff can have two types of rankings: Lecturer, Senior Lecturer, Head of Department. Let's assume 1 stands for the Lecturer rank, and 2 stands for Senior Lecturer, and 3 stands for Head of Department. We will call this value rank . Part-time academic staff do not have a ranking to climb. Full-time academic staff are required to contribute hours either into the research field or undergo trainings. For now, let's assume the hours spent on these duties stack together with each other. We will call this value contributionHours . Let's also assume that part-time academic staff, on the other hand, are not expected to offer such contributions to the College. Part-time staff work on an hourly wage rate ( hourlyRate ). The salary amount paid to part-time staff is dependent on the product of their hourly wage rate and the number of hours worked. Full-time staff, on the other hand, are paid a baseline salary amount ( baseSalary ), plus any bonus received. Implementing the Idea AcademicStaff.java We begin by implementing the superclass first; name it AcademicStaff . Let's assume that the AcademicStaff class also has 3 methods: toString() , printStaff() and calculateSalary() . For now, we will say that calculateSalary() will immediately return 0 from a generic AcademicStaff object. We will also implement toString() as a method that returns a String - the reason for this will be explained when we touch on Polymorphism next week. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor public AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } // Accessor and Mutator Methods public String getFullName () { return fullName ; } public String getId () { return id ; } public int getQualificationLevel () { return qualificationLevel ; } public void setFullName ( String fullName ) { this . fullName = fullName ; } public void setId ( String id ) { this . id = id ; } public void setQualificationLevel ( int qualificationLevel ) { this . qualificationLevel = qualificationLevel ; } public String toString () { String qualification = \"\" ; switch ( qualificationLevel ) { case 1 : qualification = \"Bachelor\" ; break ; case 2 : qualification = \"Master\" ; break ; case 3 : qualification = \"Doctorate\" ; break ; default : } return \"Full Name: \" + fullName + \"\\nStaff ID: \" + id + \"\\nQualification Type: \" + qualification ; } public void printStaff () { System . out . println ( this . toString ()); } public double calculateSalary () { return 0 ; } } We will now implement the subclasses next. FullTimeStaff.java We've already established the fact that full-time staff's salary is equal to the base salary + bonus for the month. Let's assume that the FullTimeStaff class has a specific method that is used during the calculation of the salary such that the bonus depends on the amount of contribution hours put in. Specifically, assume \\[ \\text{Bonus Received} = \\$(\\text{Number of contribution hours} \\times 100 ) \\] We will call this method getBonus() . FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructor public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } // Accessor and Mutator Methods public int getRank () { return rank ; } public int getContributionHours () { return contributionHours ; } public double getBaseSalary () { return baseSalary ; } public void setRank ( int rank ) { this . rank = rank ; } public void setContributionHours ( int contributionHours ) { this . contributionHours = contributionHours ; } public void setBaseSalary ( double baseSalary ) { this . baseSalary = baseSalary ; } // Determines bonus amount public double getBonus () { return contributionHours * 100 ; } } Recall that in order for a subclass to be able to call a method or constructor belonging to the superclass, you will need to use the super keyword. PartTimeStaff.java There are also some specifics for the part-time staff. Let's assume that one may add hours the number of hours worked in addition to the number of hours already being worked on. We'll name this method addHoursWorked() , which takes in one parameter value called additionalHours . PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructor public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } // Accessor and Mutator Methods public double getHourlyRate () { return hourlyRate ; } public int getHoursWorked () { return hoursWorked ; } public void setHourlyRate ( double hourlyRate ) { this . hourlyRate = hourlyRate ; } public void setHoursWorked ( int hoursWorked ) { this . hoursWorked = hoursWorked ; } // Add hours worked public void addHoursWorked ( int additionalHours ) { this . hoursWorked += additionalHours ; } } Driver Program Let's create a separate class acting as the driver class which will contain the main method. We can create objects of each subclass like as follows: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Driver { public static void main ( String [] args ) { FullTimeStaff staff1 = new FullTimeStaff ( \"Horace Diaz\" , \"ABC123\" , 3 , 3 , 10 , 3000 ); System . out . println ( staff1 . toString ()); System . out . println ( \"\\n\" ); PartTimeStaff staff2 = new PartTimeStaff ( \"Ivan Lam\" , \"XYZ787\" , 2 , 125 , 20 ); System . out . println ( staff2 . toString ()); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); staff2 . addHoursWorked ( 5 ); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); } } At the end of this activity, you should be able to implement inheritance in your program. However, we are not done with this program just yet. There are still the calculation of salary still displaying 0 if the respective method is called, and each of the subclass' toString() methods does not show any difference. Output: Full Name: Horace Diaz Staff ID: ABC123 Qualification Type: Doctorate Full Name: Ivan Lam Staff ID: XYZ787 Qualification Type: Master (Staff2) Hours worked: 20 (Staff2) Hours worked: 25 We will get into those during the next practical.","title":"Practical 07: Inheritance"},{"location":"lab07/#practical-07-inheritance","text":"Inheritance is one of the key concepts in object-oriented programming. With it, one can group similar elements (i.e., attributes and/or methods) of a group of classes and stash them in a superclass/parent class. The separate classes (now subclasses/child classes) will inherit these similar elements while having their own unique elements that make them different from the other fellow subclasses.","title":"Practical 07: Inheritance"},{"location":"lab07/#activity-implementing-is-a-relationships","text":"Inheritance defines relationships between classes, the \"IS-A\" relationship type in particular.","title":"Activity: Implementing \"IS-A\" Relationships"},{"location":"lab07/#illustration-example","text":"To illustrate this, let's compare two different groups of academic staff in Taylor's College, namely the full-time staff and part-time staff. Here, we are implying the following: A full-time academic staff member \" IS-A \" academic staff. A part-time academic staff member \" IS-A \" academic staff. Ignore the grammatical error, the idea's to show relations between these superclass and subclasses. \ud83d\ude1d On a base level, every academic staff has common attributes including: full name ( fullName ) staff ID ( id ) qualification level (assume 1 stands for Bachelor, 2 stands for Masters, and 3 stands for PhD) ( qualificationLevel ) Now let's compare some differences between the two types of staff: Full time academic staff can have two types of rankings: Lecturer, Senior Lecturer, Head of Department. Let's assume 1 stands for the Lecturer rank, and 2 stands for Senior Lecturer, and 3 stands for Head of Department. We will call this value rank . Part-time academic staff do not have a ranking to climb. Full-time academic staff are required to contribute hours either into the research field or undergo trainings. For now, let's assume the hours spent on these duties stack together with each other. We will call this value contributionHours . Let's also assume that part-time academic staff, on the other hand, are not expected to offer such contributions to the College. Part-time staff work on an hourly wage rate ( hourlyRate ). The salary amount paid to part-time staff is dependent on the product of their hourly wage rate and the number of hours worked. Full-time staff, on the other hand, are paid a baseline salary amount ( baseSalary ), plus any bonus received.","title":"Illustration Example"},{"location":"lab07/#implementing-the-idea","text":"","title":"Implementing the Idea"},{"location":"lab07/#academicstaffjava","text":"We begin by implementing the superclass first; name it AcademicStaff . Let's assume that the AcademicStaff class also has 3 methods: toString() , printStaff() and calculateSalary() . For now, we will say that calculateSalary() will immediately return 0 from a generic AcademicStaff object. We will also implement toString() as a method that returns a String - the reason for this will be explained when we touch on Polymorphism next week. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor public AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } // Accessor and Mutator Methods public String getFullName () { return fullName ; } public String getId () { return id ; } public int getQualificationLevel () { return qualificationLevel ; } public void setFullName ( String fullName ) { this . fullName = fullName ; } public void setId ( String id ) { this . id = id ; } public void setQualificationLevel ( int qualificationLevel ) { this . qualificationLevel = qualificationLevel ; } public String toString () { String qualification = \"\" ; switch ( qualificationLevel ) { case 1 : qualification = \"Bachelor\" ; break ; case 2 : qualification = \"Master\" ; break ; case 3 : qualification = \"Doctorate\" ; break ; default : } return \"Full Name: \" + fullName + \"\\nStaff ID: \" + id + \"\\nQualification Type: \" + qualification ; } public void printStaff () { System . out . println ( this . toString ()); } public double calculateSalary () { return 0 ; } } We will now implement the subclasses next.","title":"AcademicStaff.java"},{"location":"lab07/#fulltimestaffjava","text":"We've already established the fact that full-time staff's salary is equal to the base salary + bonus for the month. Let's assume that the FullTimeStaff class has a specific method that is used during the calculation of the salary such that the bonus depends on the amount of contribution hours put in. Specifically, assume \\[ \\text{Bonus Received} = \\$(\\text{Number of contribution hours} \\times 100 ) \\] We will call this method getBonus() . FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructor public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } // Accessor and Mutator Methods public int getRank () { return rank ; } public int getContributionHours () { return contributionHours ; } public double getBaseSalary () { return baseSalary ; } public void setRank ( int rank ) { this . rank = rank ; } public void setContributionHours ( int contributionHours ) { this . contributionHours = contributionHours ; } public void setBaseSalary ( double baseSalary ) { this . baseSalary = baseSalary ; } // Determines bonus amount public double getBonus () { return contributionHours * 100 ; } } Recall that in order for a subclass to be able to call a method or constructor belonging to the superclass, you will need to use the super keyword.","title":"FullTimeStaff.java"},{"location":"lab07/#parttimestaffjava","text":"There are also some specifics for the part-time staff. Let's assume that one may add hours the number of hours worked in addition to the number of hours already being worked on. We'll name this method addHoursWorked() , which takes in one parameter value called additionalHours . PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructor public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } // Accessor and Mutator Methods public double getHourlyRate () { return hourlyRate ; } public int getHoursWorked () { return hoursWorked ; } public void setHourlyRate ( double hourlyRate ) { this . hourlyRate = hourlyRate ; } public void setHoursWorked ( int hoursWorked ) { this . hoursWorked = hoursWorked ; } // Add hours worked public void addHoursWorked ( int additionalHours ) { this . hoursWorked += additionalHours ; } }","title":"PartTimeStaff.java"},{"location":"lab07/#driver-program","text":"Let's create a separate class acting as the driver class which will contain the main method. We can create objects of each subclass like as follows: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Driver { public static void main ( String [] args ) { FullTimeStaff staff1 = new FullTimeStaff ( \"Horace Diaz\" , \"ABC123\" , 3 , 3 , 10 , 3000 ); System . out . println ( staff1 . toString ()); System . out . println ( \"\\n\" ); PartTimeStaff staff2 = new PartTimeStaff ( \"Ivan Lam\" , \"XYZ787\" , 2 , 125 , 20 ); System . out . println ( staff2 . toString ()); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); staff2 . addHoursWorked ( 5 ); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); } } At the end of this activity, you should be able to implement inheritance in your program. However, we are not done with this program just yet. There are still the calculation of salary still displaying 0 if the respective method is called, and each of the subclass' toString() methods does not show any difference. Output: Full Name: Horace Diaz Staff ID: ABC123 Qualification Type: Doctorate Full Name: Ivan Lam Staff ID: XYZ787 Qualification Type: Master (Staff2) Hours worked: 20 (Staff2) Hours worked: 25 We will get into those during the next practical.","title":"Driver Program"},{"location":"lab08/","text":"Practical 08: Polymorphism Polymorphism is another key concept in object-oriented programming. It refers to the capability of objects to react differently to the same method. Polymorphism can be implemented in the form of multiple methods having the same name. Java code uses a late-binding technique to support polymorphism; the method to be invoked is decided at runtime. Activity: Overloading Methods vs. Overriding Methods Overloaded methods are methods that have the same name, but different argument lists. Overriding , on the other hand, occurs when a subclass method has the same name, same return type, and same argument list as the superclass method. Overloading Methods One example of overloading methods that we have already covered during lecture when we first began going through classes and objects is through the use of multiple constructors. Going back to the previous activity, let's look at the FullTimeStaff class. Here, let's assume that if baseSalary isn't specified, it will be determined immediately by the rank entered. We'll now create a separate constructor method that takes in the same parameters, except baseSalary is excluded from this list. FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; switch ( this . rank ) { case 1 : this . baseSalary = 2000 ; break ; case 2 : this . baseSalary = 2500 ; break ; case 3 : this . baseSalary = 3000 ; break ; default : this . baseSalary = 0 ; } } /* ... */ } We can do the same with the PartTimeStaff class, but with hoursWorked undefined. In this case, hoursWorked to 0 if unspecified. PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; hoursWorked = 0 ; } /* ... */ } Overloading methods isn't just restricted to constructors; this can be applied from a procedural programming standpoint. Let's assume that this class has two methods that print out the area of a shape given two different sets of parameters. Shape.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Shape { // Get area of quadrilateral public double getArea ( double width , double height ) { return width * height ; } // Get area of circle public double getArea ( double radius ) { return Math . PI * radius * radius ; } /* ... */ } The key idea behind overloading methods is to have methods of the same name, but different argument lists . Here, depending on whether one double value or two double values are entered, you get two different methods of calculating the area of the shape. Overloading methods is also not restricted by the return type being used. For example, one may create a getArea() method that returns an integer value based on yet another argument list. The number of times a method is overloaded is not restricted as well, but ensure not to have ambiguous parameter lists like as follows: Shape.java 1 2 3 4 5 6 7 8 9 10 11 public class Shape { public double getArea ( double width , double height ) { /* ... */ } public double getArea ( double radius , int dimension ) { /* ... */ } /* ... */ } Here, the compiler does not know which method to use when invoked with a parameter list where the second number can be interpreted as either an integer or double. Overriding Methods Overriding methods involve having methods of the same name, return type, and argument list between superclass and subclass. Going back to last week's activity again, we will now override the toString() and calculateSalary() methods of both subclasses. FullTimeStaff.java FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class FullTimeStaff extends AcademicStaff { /* ... */ public double calculateSalary () { return baseSalary + getBonus (); } public String toString () { String rankName = \"\" ; switch ( rank ) { case 1 : rankName = \"Lecturer\" ; break ; case 2 : rankName = \"Senior Lecturer\" ; break ; case 3 : rankName = \"Professor\" ; break ; default : } return super . toString () + \"\\nStaff Rank: \" + rankName ; } } PartTimeStaff.java PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 public class PartTimeStaff extends AcademicStaff { /* ... */ public double calculateSalary () { return hourlyRate * hoursWorked ; } public String toString () { return super . toString () + \"\\nStaff Rank: Part-Time Lecturer\" ; } } In this example, we have already overriden toString() twice, once between the superclass and subclass we have just created, and the other via overriding from the Object class. In Java, all classes are considered subclasses of the Object class, which in turn, is the superclass of just about any class that exists in Java and any class you create. Java's Object class contains the toString() method by default, which prints out the memory address the object is taking up. This is not particularly helpful to us as regular users who pay no regard to where about the object is specifically being stored in the computer's memory. Making the following modifications to the main method in the driver class will render the following output: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Driver { public static void main ( String [] args ) { FullTimeStaff staff1 = new FullTimeStaff ( \"Horace Diaz\" , \"ABC123\" , 3 , 3 , 10 , 3000 ); System . out . println ( staff1 . toString ()); System . out . printf ( \"(Staff1) Salary: $ %.2f\" , staff1 . calculateSalary ()); System . out . println ( \"\\n\" ); PartTimeStaff staff2 = new PartTimeStaff ( \"Ivan Lam\" , \"XYZ787\" , 2 , 125 , 20 ); System . out . println ( staff2 . toString ()); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); staff2 . addHoursWorked ( 5 ); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); System . out . printf ( \"(Staff2) Salary: $ %.2f\" , staff1 . calculateSalary ()); } } Output: Full Name: Horace Diaz Staff ID: ABC123 Qualification Type: Doctorate Staff Rank: Professor (Staff1) Salary: $ 4000.00 Full Name: Ivan Lam Staff ID: XYZ787 Qualification Type: Master Staff Rank: Part-Time Lecturer (Staff2) Hours worked: 20 (Staff2) Hours worked: 25 (Staff2) Salary: $ 3125.00 Optional Activity: Subtype Polymorphism Subtype polymorphism (also known as subtyping or inclusion polymorphism) is a type of polymorphism in which an object can change its class based on its base class (superclass). Provided that the declaration is done using the object\u2019s base class, the object can substitute its class with any classes that are subclasses of that superclass. In our example, let's create yet another constructor in each of the subclasses to simulate a promotion/demotion act between full-time and part-time statuses. FullTimeStaff.java FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; switch ( this . rank ) { case 1 : this . baseSalary = 2000 ; break ; case 2 : this . baseSalary = 2500 ; break ; case 3 : this . baseSalary = 3000 ; break ; default : this . baseSalary = 0 ; } } public FullTimeStaff ( PartTimeStaff pt , int rank , int contributionHours ) { this ( pt . getFullName (), pt . getId (), pt . getQualificationLevel (), rank , contributionHours ); } /* ... */ } PartTimeStaff.java PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; hoursWorked = 0 ; } public PartTimeStaff ( FullTimeStaff ft , double hourlyRate ) { this ( ft . getFullName (), ft . getId (), ft . getQualificationLevel (), hourlyRate ); } /* ... */ } Try invoking these newly created constructors in your driver class to promote and demote the already created objects. Tasks Task 1 Consider the class diagram given below: Employee Superclass with Manager and Clerk Subclasses Implement all the classes as according to the given hierarchy. Write a test program that creates an array named empArray that stores an object of an Employee, a Manager, and a Clerk. In your program, include a method called printElements() that takes an array as a parameter and prints the type of employee, the object's data field values (by invoking the toString() method) and the monthly salary. Override the Object class' equals() method in Employee, Manager, and clerk classes. For each class, assume that two objects are considered equal if they have the same name. Test the equals() method on all derived types of Employee. Task 2 A bank offers its customers the following account types: The savings account earns interest that compounds monthly (i.e., the interest is calculated based on the balance on the last day of the month). The checking account has no interest, but the customer is given a small number of free transactions per month and is charged a nominal fee for each additional transaction. Create a superclass Account that has the properties account number, balance, and date created, as well as methods for deposit and withdrawal. Create two subclasses for saving and checking accounts. Write a test program that creates objects of the classes Account , SavingsAccount , and CheckingAccount .","title":"Practical 08: Polymorphism"},{"location":"lab08/#practical-08-polymorphism","text":"Polymorphism is another key concept in object-oriented programming. It refers to the capability of objects to react differently to the same method. Polymorphism can be implemented in the form of multiple methods having the same name. Java code uses a late-binding technique to support polymorphism; the method to be invoked is decided at runtime.","title":"Practical 08: Polymorphism"},{"location":"lab08/#activity-overloading-methods-vs-overriding-methods","text":"Overloaded methods are methods that have the same name, but different argument lists. Overriding , on the other hand, occurs when a subclass method has the same name, same return type, and same argument list as the superclass method.","title":"Activity: Overloading Methods vs. Overriding Methods"},{"location":"lab08/#overloading-methods","text":"One example of overloading methods that we have already covered during lecture when we first began going through classes and objects is through the use of multiple constructors. Going back to the previous activity, let's look at the FullTimeStaff class. Here, let's assume that if baseSalary isn't specified, it will be determined immediately by the rank entered. We'll now create a separate constructor method that takes in the same parameters, except baseSalary is excluded from this list. FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; switch ( this . rank ) { case 1 : this . baseSalary = 2000 ; break ; case 2 : this . baseSalary = 2500 ; break ; case 3 : this . baseSalary = 3000 ; break ; default : this . baseSalary = 0 ; } } /* ... */ } We can do the same with the PartTimeStaff class, but with hoursWorked undefined. In this case, hoursWorked to 0 if unspecified. PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; hoursWorked = 0 ; } /* ... */ } Overloading methods isn't just restricted to constructors; this can be applied from a procedural programming standpoint. Let's assume that this class has two methods that print out the area of a shape given two different sets of parameters. Shape.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Shape { // Get area of quadrilateral public double getArea ( double width , double height ) { return width * height ; } // Get area of circle public double getArea ( double radius ) { return Math . PI * radius * radius ; } /* ... */ } The key idea behind overloading methods is to have methods of the same name, but different argument lists . Here, depending on whether one double value or two double values are entered, you get two different methods of calculating the area of the shape. Overloading methods is also not restricted by the return type being used. For example, one may create a getArea() method that returns an integer value based on yet another argument list. The number of times a method is overloaded is not restricted as well, but ensure not to have ambiguous parameter lists like as follows: Shape.java 1 2 3 4 5 6 7 8 9 10 11 public class Shape { public double getArea ( double width , double height ) { /* ... */ } public double getArea ( double radius , int dimension ) { /* ... */ } /* ... */ } Here, the compiler does not know which method to use when invoked with a parameter list where the second number can be interpreted as either an integer or double.","title":"Overloading Methods"},{"location":"lab08/#overriding-methods","text":"Overriding methods involve having methods of the same name, return type, and argument list between superclass and subclass. Going back to last week's activity again, we will now override the toString() and calculateSalary() methods of both subclasses.","title":"Overriding Methods"},{"location":"lab08/#fulltimestaffjava","text":"FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class FullTimeStaff extends AcademicStaff { /* ... */ public double calculateSalary () { return baseSalary + getBonus (); } public String toString () { String rankName = \"\" ; switch ( rank ) { case 1 : rankName = \"Lecturer\" ; break ; case 2 : rankName = \"Senior Lecturer\" ; break ; case 3 : rankName = \"Professor\" ; break ; default : } return super . toString () + \"\\nStaff Rank: \" + rankName ; } }","title":"FullTimeStaff.java"},{"location":"lab08/#parttimestaffjava","text":"PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 public class PartTimeStaff extends AcademicStaff { /* ... */ public double calculateSalary () { return hourlyRate * hoursWorked ; } public String toString () { return super . toString () + \"\\nStaff Rank: Part-Time Lecturer\" ; } } In this example, we have already overriden toString() twice, once between the superclass and subclass we have just created, and the other via overriding from the Object class. In Java, all classes are considered subclasses of the Object class, which in turn, is the superclass of just about any class that exists in Java and any class you create. Java's Object class contains the toString() method by default, which prints out the memory address the object is taking up. This is not particularly helpful to us as regular users who pay no regard to where about the object is specifically being stored in the computer's memory. Making the following modifications to the main method in the driver class will render the following output: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Driver { public static void main ( String [] args ) { FullTimeStaff staff1 = new FullTimeStaff ( \"Horace Diaz\" , \"ABC123\" , 3 , 3 , 10 , 3000 ); System . out . println ( staff1 . toString ()); System . out . printf ( \"(Staff1) Salary: $ %.2f\" , staff1 . calculateSalary ()); System . out . println ( \"\\n\" ); PartTimeStaff staff2 = new PartTimeStaff ( \"Ivan Lam\" , \"XYZ787\" , 2 , 125 , 20 ); System . out . println ( staff2 . toString ()); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); staff2 . addHoursWorked ( 5 ); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); System . out . printf ( \"(Staff2) Salary: $ %.2f\" , staff1 . calculateSalary ()); } } Output: Full Name: Horace Diaz Staff ID: ABC123 Qualification Type: Doctorate Staff Rank: Professor (Staff1) Salary: $ 4000.00 Full Name: Ivan Lam Staff ID: XYZ787 Qualification Type: Master Staff Rank: Part-Time Lecturer (Staff2) Hours worked: 20 (Staff2) Hours worked: 25 (Staff2) Salary: $ 3125.00","title":"PartTimeStaff.java"},{"location":"lab08/#optional-activity-subtype-polymorphism","text":"Subtype polymorphism (also known as subtyping or inclusion polymorphism) is a type of polymorphism in which an object can change its class based on its base class (superclass). Provided that the declaration is done using the object\u2019s base class, the object can substitute its class with any classes that are subclasses of that superclass. In our example, let's create yet another constructor in each of the subclasses to simulate a promotion/demotion act between full-time and part-time statuses.","title":"Optional Activity: Subtype Polymorphism"},{"location":"lab08/#fulltimestaffjava_1","text":"FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; switch ( this . rank ) { case 1 : this . baseSalary = 2000 ; break ; case 2 : this . baseSalary = 2500 ; break ; case 3 : this . baseSalary = 3000 ; break ; default : this . baseSalary = 0 ; } } public FullTimeStaff ( PartTimeStaff pt , int rank , int contributionHours ) { this ( pt . getFullName (), pt . getId (), pt . getQualificationLevel (), rank , contributionHours ); } /* ... */ }","title":"FullTimeStaff.java"},{"location":"lab08/#parttimestaffjava_1","text":"PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; hoursWorked = 0 ; } public PartTimeStaff ( FullTimeStaff ft , double hourlyRate ) { this ( ft . getFullName (), ft . getId (), ft . getQualificationLevel (), hourlyRate ); } /* ... */ } Try invoking these newly created constructors in your driver class to promote and demote the already created objects.","title":"PartTimeStaff.java"},{"location":"lab08/#tasks","text":"","title":"Tasks"},{"location":"lab08/#task-1","text":"Consider the class diagram given below: Employee Superclass with Manager and Clerk Subclasses Implement all the classes as according to the given hierarchy. Write a test program that creates an array named empArray that stores an object of an Employee, a Manager, and a Clerk. In your program, include a method called printElements() that takes an array as a parameter and prints the type of employee, the object's data field values (by invoking the toString() method) and the monthly salary. Override the Object class' equals() method in Employee, Manager, and clerk classes. For each class, assume that two objects are considered equal if they have the same name. Test the equals() method on all derived types of Employee.","title":"Task 1"},{"location":"lab08/#task-2","text":"A bank offers its customers the following account types: The savings account earns interest that compounds monthly (i.e., the interest is calculated based on the balance on the last day of the month). The checking account has no interest, but the customer is given a small number of free transactions per month and is charged a nominal fee for each additional transaction. Create a superclass Account that has the properties account number, balance, and date created, as well as methods for deposit and withdrawal. Create two subclasses for saving and checking accounts. Write a test program that creates objects of the classes Account , SavingsAccount , and CheckingAccount .","title":"Task 2"},{"location":"lab09/","text":"Practical 09: Abstract Classes and Interfaces If you look into the hierarchy of classes in Java, you may find that you are not able to create objects out of certain superclasses. This is often because having objects based on the structure of such superclasses don't make sense. In such cases like these, we often keep these classes (and sometimes some of their methods as well) as abstract. Activity: Implementing an Abstract Class and Abstract Methods Looking back at the program we just went through for the past two weeks, it is not very useful to have objects of just the Employee class. We can change it into an abstract class by adding the abstract keyword in the class declaration like as follows: AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ public double calculateSalary () { return 0 ; } } Here, we also modified the constructor declaration to use the protected keyword instead of the public keyword. It barely makes a difference for the time being, but it does ensure that it cannot be invoked unless from a linked subclass. Note that in this class, the calculateSalary() method is also not useful. Apart from creating abstract classes, the abstract keyword can be used to create abstract methods as and when necessary. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ public abstract double calculateSalary (); } Abstract methods can still be overridden by subclasses. However, the visibility modifier of such declarations cannot be more private than that implemented in the superclass. In this case, you are not allowed to override the calculateSalary() method with any other visibility modifier apart from public . However, if the declaration here in the superclass is protected for example, subclasses can use the same visibility modifier or use a less private one like public . AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ protected abstract double calculateSalary (); } Implementing a Simple Interface Let's create an interface class named Manners . We will only implement it in the AcademicStaff class, but the methods introduced from the Manners interface will be reflected on the related subclasses. This interface will have one method called introduce() , but there is no restriction as to how many methods are introduced here. Manners.java public interface Manners { void introduce (); } In order to introduce the use of this interface in the AcademicStaff class, introduce it using the implements keyword like as follows: AcademicStaff.java 1 2 3 public class AcademicStaff implements Manners { /* ... */ } Note The usage of the implements keyword can be used alongside the extends keyword, should an interface ever need to be implemented on a subclass. When implementing an interface, one would require the method to be implemented. In the AcademicStaff class, assume that the introduce() prints out a greeting statement. AcademicStaff.java 1 2 3 4 5 6 7 public class AcademicStaff implements Manners { /* ... */ public void introduce () { System . out . println ( \"Hi, I'm \" + fullName + \"!\" ); } } Optional Activity How would you implement this interface in the subclasses should you want the introduce() method to act differently based on which subclass it is being called from? Task In this practical task, you will build simple programs using abstract classes. You will also learn how to add polymorphic behavior to the program using abstract methods. Product.java The skeleton code for Product.java is given below. The Product class is an abstract class that has an abstract method called computeSalePrice() . Product.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Product class is now an abstract class public abstract class Product { private double regularPrice ; // Creates a new instance of Product public Product ( double regularPrice ) { this . regularPrice = regularPrice ; } // computeSalesPrice() is now an abstract method public abstract double computeSalePrice (); public double getRegularPrice () { return regularPrice ; } public void setRegularPrice ( double regularPrice ) { this . regularPrice = regularPrice ; } } Electronics.java The Electronics class itself is an abstract class because it does not provide implementation of the computeSalePrice() abstract method. Electronics.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Electronics class is now an abstract class because it does not provide * implementation of the computeSalePrice() abstract method. */ public abstract class Electronics extends Product { private String manufacturer ; // Creates a new instance of Electronics public Electronics ( double regularPrice , String manufacturer ) { super ( regularPrice ); this . manufacturer = manufacturer ; } public String getManufacturer () { return manufacturer ; } public void setManufacturer ( String manufacturer ) { this . manufacturer = manufacturer ; } } Write MP3Player.java . The MP3Player class extends the Electronics class. The MP3Player class should implement the computeSalePrice() method with the following statement: return super . getRegularPrice () * 0.9 ; Note: In addition to the implementation of the abstract method, you might also need to include a constructor or instance variable. Write TV.java . The TV class extends the Electronics abstract class. The TV class should also implement the computeSalePrice() method, but with the following statement: return super . getRegularPrice () * 0.8 ; Note: In addition to the implementation of the abstract method, you might also need to include a constructor or instance variable. Complete Book.java . The Book class extends the Product class. The Book class should also implement the computeSalePrice() method, but with the following statement: return super . getRegularPrice () * 0.5 ; You may continue with the given code for Book.java as follows: Book.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Book extends Product { private String publisher ; private int yearPublished ; // Creates a new instance of Book public Book ( double regularPrice , String publisher , int yearPublished ) { super ( regularPrice ); } // Implement abstract method here public String getPublisher () { return publisher ; } public void setPublisher ( String publisher ) { this . publisher = publisher ; } public int getYearPublished () { return yearPublished ; } public void setYearPublished ( int yearPublished ) { this . yearPublished = yearPublished ; } } Run Main.java . Main.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Main { public static void main ( String [] args ) { // Declare and create Product array of size 5 Product [] pa = new Product [ 5 ] ; /** * Create object instances and assign them to * the type of Product. */ pa [ 0 ] = new TV ( 1000 , \"Samsung\" , 30 ); pa [ 1 ] = new TV ( 2000 , \"Sony\" , 50 ); pa [ 2 ] = new MP3Player ( 250 , \"Apple\" , \"blue\" ); pa [ 3 ] = new Book ( 34 , \"Sun Press\" , 1992 ); pa [ 4 ] = new Book ( 15 , \"Korea Press\" , 1986 ); // Compute total regular price and total sale price double totalRegularPrice = 0 ; double totalSalePrice = 0 ; for ( int i = 0 ; i < pa . length ; i ++ ) { /** * Call a method of the superclass to get * the regular price. */ totalRegularPrice += pa [ i ] . getRegularPrice (); /** * Since the sale price is computed differently * depending on the product type, overriding * (implementation) method of the object instance * of the subclass gets invoked. This is runtime * polymorphic behavior. */ totalSalePrice += pa [ i ] . computeSalePrice (); System . out . println ( \"Item number \" + i + \": Type = \" + pa [ i ] . getClass (). getName () + \", Regular price = \" + pa [ i ] . getRegularPrice () + \", Sale price = \" + pa [ i ] . computeSalePrice ()); } System . out . println ( \"totalRegularPrice = \" + totalRegularPrice ); System . out . println ( \"totalSalePrice = \" + totalSalePrice ); } } You should observe the following output results: Item number 0: Type = myonlineshop.TV, Regular price = 1000.0, Sale price = 800.0 Item number 1: Type = myonlineshop.TV, Regular price = 2000.0, Sale price = 1600.0 Item number 2: Type = myonlineshop.MP3Player, Regular price = 250.0, Sale price = 225.0 Item number 3: Type = myonlineshop.Book, Regular price = 34.0, Sale price = 17.0 Item number 4: Type = myonlineshop.Book, Regular price = 15.0, Sale price = 7.5 totalRegularPrice = 3299.0 totalSalePrice = 2649.5","title":"Practical 09: Abstract Classes and Interfaces"},{"location":"lab09/#practical-09-abstract-classes-and-interfaces","text":"If you look into the hierarchy of classes in Java, you may find that you are not able to create objects out of certain superclasses. This is often because having objects based on the structure of such superclasses don't make sense. In such cases like these, we often keep these classes (and sometimes some of their methods as well) as abstract.","title":"Practical 09: Abstract Classes and Interfaces"},{"location":"lab09/#activity-implementing-an-abstract-class-and-abstract-methods","text":"Looking back at the program we just went through for the past two weeks, it is not very useful to have objects of just the Employee class. We can change it into an abstract class by adding the abstract keyword in the class declaration like as follows: AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ public double calculateSalary () { return 0 ; } } Here, we also modified the constructor declaration to use the protected keyword instead of the public keyword. It barely makes a difference for the time being, but it does ensure that it cannot be invoked unless from a linked subclass. Note that in this class, the calculateSalary() method is also not useful. Apart from creating abstract classes, the abstract keyword can be used to create abstract methods as and when necessary. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ public abstract double calculateSalary (); } Abstract methods can still be overridden by subclasses. However, the visibility modifier of such declarations cannot be more private than that implemented in the superclass. In this case, you are not allowed to override the calculateSalary() method with any other visibility modifier apart from public . However, if the declaration here in the superclass is protected for example, subclasses can use the same visibility modifier or use a less private one like public . AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ protected abstract double calculateSalary (); }","title":"Activity: Implementing an Abstract Class and Abstract Methods"},{"location":"lab09/#implementing-a-simple-interface","text":"Let's create an interface class named Manners . We will only implement it in the AcademicStaff class, but the methods introduced from the Manners interface will be reflected on the related subclasses. This interface will have one method called introduce() , but there is no restriction as to how many methods are introduced here. Manners.java public interface Manners { void introduce (); } In order to introduce the use of this interface in the AcademicStaff class, introduce it using the implements keyword like as follows: AcademicStaff.java 1 2 3 public class AcademicStaff implements Manners { /* ... */ } Note The usage of the implements keyword can be used alongside the extends keyword, should an interface ever need to be implemented on a subclass. When implementing an interface, one would require the method to be implemented. In the AcademicStaff class, assume that the introduce() prints out a greeting statement. AcademicStaff.java 1 2 3 4 5 6 7 public class AcademicStaff implements Manners { /* ... */ public void introduce () { System . out . println ( \"Hi, I'm \" + fullName + \"!\" ); } }","title":"Implementing a Simple Interface"},{"location":"lab09/#optional-activity","text":"How would you implement this interface in the subclasses should you want the introduce() method to act differently based on which subclass it is being called from?","title":"Optional Activity"},{"location":"lab09/#task","text":"In this practical task, you will build simple programs using abstract classes. You will also learn how to add polymorphic behavior to the program using abstract methods.","title":"Task"},{"location":"lab09/#productjava","text":"The skeleton code for Product.java is given below. The Product class is an abstract class that has an abstract method called computeSalePrice() . Product.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Product class is now an abstract class public abstract class Product { private double regularPrice ; // Creates a new instance of Product public Product ( double regularPrice ) { this . regularPrice = regularPrice ; } // computeSalesPrice() is now an abstract method public abstract double computeSalePrice (); public double getRegularPrice () { return regularPrice ; } public void setRegularPrice ( double regularPrice ) { this . regularPrice = regularPrice ; } }","title":"Product.java"},{"location":"lab09/#electronicsjava","text":"The Electronics class itself is an abstract class because it does not provide implementation of the computeSalePrice() abstract method. Electronics.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Electronics class is now an abstract class because it does not provide * implementation of the computeSalePrice() abstract method. */ public abstract class Electronics extends Product { private String manufacturer ; // Creates a new instance of Electronics public Electronics ( double regularPrice , String manufacturer ) { super ( regularPrice ); this . manufacturer = manufacturer ; } public String getManufacturer () { return manufacturer ; } public void setManufacturer ( String manufacturer ) { this . manufacturer = manufacturer ; } } Write MP3Player.java . The MP3Player class extends the Electronics class. The MP3Player class should implement the computeSalePrice() method with the following statement: return super . getRegularPrice () * 0.9 ; Note: In addition to the implementation of the abstract method, you might also need to include a constructor or instance variable. Write TV.java . The TV class extends the Electronics abstract class. The TV class should also implement the computeSalePrice() method, but with the following statement: return super . getRegularPrice () * 0.8 ; Note: In addition to the implementation of the abstract method, you might also need to include a constructor or instance variable. Complete Book.java . The Book class extends the Product class. The Book class should also implement the computeSalePrice() method, but with the following statement: return super . getRegularPrice () * 0.5 ; You may continue with the given code for Book.java as follows: Book.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Book extends Product { private String publisher ; private int yearPublished ; // Creates a new instance of Book public Book ( double regularPrice , String publisher , int yearPublished ) { super ( regularPrice ); } // Implement abstract method here public String getPublisher () { return publisher ; } public void setPublisher ( String publisher ) { this . publisher = publisher ; } public int getYearPublished () { return yearPublished ; } public void setYearPublished ( int yearPublished ) { this . yearPublished = yearPublished ; } } Run Main.java . Main.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Main { public static void main ( String [] args ) { // Declare and create Product array of size 5 Product [] pa = new Product [ 5 ] ; /** * Create object instances and assign them to * the type of Product. */ pa [ 0 ] = new TV ( 1000 , \"Samsung\" , 30 ); pa [ 1 ] = new TV ( 2000 , \"Sony\" , 50 ); pa [ 2 ] = new MP3Player ( 250 , \"Apple\" , \"blue\" ); pa [ 3 ] = new Book ( 34 , \"Sun Press\" , 1992 ); pa [ 4 ] = new Book ( 15 , \"Korea Press\" , 1986 ); // Compute total regular price and total sale price double totalRegularPrice = 0 ; double totalSalePrice = 0 ; for ( int i = 0 ; i < pa . length ; i ++ ) { /** * Call a method of the superclass to get * the regular price. */ totalRegularPrice += pa [ i ] . getRegularPrice (); /** * Since the sale price is computed differently * depending on the product type, overriding * (implementation) method of the object instance * of the subclass gets invoked. This is runtime * polymorphic behavior. */ totalSalePrice += pa [ i ] . computeSalePrice (); System . out . println ( \"Item number \" + i + \": Type = \" + pa [ i ] . getClass (). getName () + \", Regular price = \" + pa [ i ] . getRegularPrice () + \", Sale price = \" + pa [ i ] . computeSalePrice ()); } System . out . println ( \"totalRegularPrice = \" + totalRegularPrice ); System . out . println ( \"totalSalePrice = \" + totalSalePrice ); } } You should observe the following output results: Item number 0: Type = myonlineshop.TV, Regular price = 1000.0, Sale price = 800.0 Item number 1: Type = myonlineshop.TV, Regular price = 2000.0, Sale price = 1600.0 Item number 2: Type = myonlineshop.MP3Player, Regular price = 250.0, Sale price = 225.0 Item number 3: Type = myonlineshop.Book, Regular price = 34.0, Sale price = 17.0 Item number 4: Type = myonlineshop.Book, Regular price = 15.0, Sale price = 7.5 totalRegularPrice = 3299.0 totalSalePrice = 2649.5","title":"Electronics.java"},{"location":"lab10/","text":"Practical 10: Exception Handling Unfortunately, we live in a tragic society where there exist individuals who are fascinated with breaking stuff, and those who would rather fight for the right to do whatever they so please. This is no different with programs, but this is one way on how bugs are discovered in programs. In this practical, let's start playing the devil's advocate and do all we can to patch such problems. Who says that there is absolutely nothing that can be done to prevent their actions from affecting others? Java provides Exception classes that can be used to cater for unintended occurrences. While utilizing Exceptions are always welcome, one should try to resort to using simpler tactics whenever possible (e.g., implementing checks with if-else statements). It is also worth noting that for some languages, utilizing exception handling is not strongly encouraged. Activity: Applying Exception Handling into a Program Let's revisit that Staff program we just around to developing these past three practical sessions. We'll begin with the abstract parent class AcademicStaff.java . AcademicStaff.java AcademicStaff.java has attributes fullName , id , and qualificationLevel . From the way we've implemented the qualificationLevel attribute, it can take one of 3 values: 1 (Bachelor), 2 (Master), or 3 (Doctorate). Let's make it such that when initializing an AcademicStaff object, it throws an Exception when any other value is received for qualificationLevel (not that it can now since it's abstract, but it will do the same for the subclasses). We will now modify the mutator method for this attribute like as follows: 1 2 3 4 5 6 public void setQualificationLevel ( int qualificationLevel ) { if ( qualificationLevel < 1 || qualificationLevel > 3 ) throw new IllegalArgumentException ( \"Qualification Level must be either 1, 2, or 3!\" ); this . qualificationLevel = qualificationLevel ; } Here, we are throwing an IllegalArgumentExcpetion back to the method that called it. The IllegalArgumentExcpetion class is one of many exception classes that exist in Java. This one in particular is best used here since we can regard a qualification level which is not one of the stated values (i.e., 1-3) as an illegal argument/value. FullTimeStaff.java The rank attribute follows the same convention as with the AcademicStaff 's qualificationLevel attribute. 1 2 3 4 5 6 public void setRank ( int rank ) { if ( rank < 1 || rank > 3 ) throw new IllegalArgumentException ( \"Rank must be either 1, 2, or 3!\" ); this . rank = rank ; } For both the contributionHours and baseSalary attributes, they are expected to contain non-negative values. We can proceed to throw an exception each time a negative value is entered, or we can set it to 0 instead (this does not require throwing an Exception, rather to implement an if-else statement). The choice is entirely up to you. Throwing an Exception 1 2 3 4 5 6 public void setContributionHours ( int contributionHours ) { if ( contributionHours < 0 ) throw new IllegalArgumentException ( \"Contribution hours cannot be negative!\" ); this . contributionHours = contributionHours ; } 1 2 3 4 5 6 public void setBaseSalary ( int baseSalary ) { if ( baseSalary < 0 ) throw new IllegalArgumentException ( \"Base salary cannot be negative!\" ); this . baseSalary = baseSalary ; } Defaulting to 0 1 2 3 4 5 6 public void setContributionHours ( int contributionHours ) { if ( contributionHours < 0 ) this . contributionHours = 0 ; else this . contributionHours = contributionHours ; } 1 2 3 4 5 6 public void setBaseSalary ( int baseSalary ) { if ( baseSalary < 0 ) this . baseSalary = 0 ; else this . baseSalary = baseSalary ; } PartTimeStaff.java The same approaches to FullTimeStaff 's attributes can be done for PartTimeStaff 's hourlyRate and hoursWorked attributes. Simply modify their mutator methods to work similarly. Apart from these mutator methods, we can also modify the addHoursWorked() method such that it will not take in negative values. In this case, reverting the hoursWorked value is not appropriate. Thus, you should throw an IllegalArgumentException object instead in its place. Forcing Constructors to Use Modified Mutator Methods Let's now modify the constructors in this class as well as the two subclasses such that they use the mutator methods by default when called. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { setFullName ( fullName ); setId ( id ); setQualificationLevel ( qualificationLevel ); } /* ... */ } FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { super ( fullName , id , qualificationLevel ); setRank ( rank ); setContributionHours ( contributionHours ); setBaseSalary ( baseSalary ); } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); setRank ( rank ); setContributionHours ( contributionHours ); switch ( this . rank ) { case 1 : setBaseSalary ( 2000 ); break ; case 2 : setBaseSalary ( 2500 ); break ; case 3 : setBaseSalary ( 3000 ); break ; default : setBaseSalary ( 0 ); } } public FullTimeStaff ( PartTimeStaff pt , int rank , int contributionHours ) { this ( pt . getFullName (), pt . getId (), pt . getQualificationLevel (), rank , contributionHours ); } /* ... */ } PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); setHourlyRate ( hourlyRate ); setHoursWorked ( hoursWorked ); } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); setHourlyRate ( hourlyRate ); setHoursWorked ( 0 ); } public PartTimeStaff ( FullTimeStaff ft , double hourlyRate ) { this ( ft . getFullName (), ft . getId (), ft . getQualificationLevel (), hourlyRate ); } /* ... */ } try-catch-finally block We've implemented the classes such that they throw the appropriate Exception classes as and when necessary. However, without specifying a method of catching such Exception classes, your program will not terminate gracefully. In the driver class' main method, surround your code with the try-catch block as follows: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Driver { public static void main ( String [] args ) { try { /* testing code goes here */ } catch ( IllegalArgumentException ex ) { System . out . println ( ex . getMessage ()); } catch ( Exception ex ) { ex . printStackTrace (); } } } The program is now set to check for Exception objects being thrown from anything that is called from the try block. Once the matching Exception object is caught, the program proceeds to run the statements from within that catch block. Whatever statements yet to be run from the try block is skipped. Notice that the program checks for an IllegalArgumentException object first before a more generic Exception object. In practice, you should cater to catch specific Exception types before ending with checking for objects of the generic Exception class. Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Driver { public static void main ( String [] args ) { try { /* testing code goes here */ } catch ( IllegalArgumentException ex ) { System . out . println ( ex . getMessage ()); } catch ( Exception ex ) { ex . printStackTrace (); } finally { System . out . println ( \"End of Staff program\" ); } } } Regardless of whether an Exception is caught, if a finally block exists, all statements from this block is run. Statements in the finally block can be used to close resources (e.g., for writing to files) or display specific messages (e.g., to signal the end of the program). Now, go bonkers and see if your attempts at securing your program a little better worked! Tasks Task 1 Write a program that prompts the user to read two integers and displays their multiplication. Your program should prompt the user to read the number again if the input is incorrect. Example Output: Enter two integers: 3 a Incorrect input! Re-enter two integers: a 3 Incorrect input! Re-enter two integers: 3 3 Multiplication is 9 Task 2 Write a program that meets the following requirements: Create an array with 100 randomly chosen integers. Prompt the user to enter the array index, then display the corresponding element value. If the specified index is out of bounds, display the message \"Index out of bounds\". Example Output: Enter an index: 101 Index out of bounds Enter an index: 55 The element is 7313 Enter an index: 108 Index out of bounds Task 3 Write a class named TestScores . The class constructor should accept any array of test scores as its argument. The class should have a method that returns the average of the test scores. If any test score in the array is negative or greater than 100 then the class should throw an IllegialArugumentException with the specified detail message to its caller. Demonstrate the usage of the class in a test program. Task 4 Write a program that uses the following method to solve equations specified by the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Returns the larger of the two roots of * the quadratic equation A*x*x + B*x + C = 0. * (Throws an exception if A == 0 or B*B-4*A*C < 0.) */ public static double root ( double A , double B , double C ) throws IllegalArgumentException { if ( A == 0 ) { throw new IllegalArgumentException ( \"A can't be zero.\" ); } else { double disc = B * B - 4 * A * C ; if ( disc < 0 ) throw new IllegalArgumentException ( \"Discriminant < zero.\" ); return ( - B + Math . sqrt ( disc )) / ( 2 * A ); } } Your program should allow the user to specify values for A , B , and C . It should call the method to compute a solution of the equation. If no error occurs, it should print the root. However, if an error occurs, your program should catch that error and print an error message. After processing one equation, the program should ask whether the user wants to enter another equation. The program should continue until the user answers no. Optional Task (Challenge Question) Write a calculator program. The program terminates if any operand is non-numeric. Write a program with an exception handler that deals with non-numeric operands; then write another program without using an exception handler to achieve the same objective. Your program should display a message that informs the user of the wrong operand type before exiting. Example Output: Input: 5 + y Wrong Input: y Input: 4f x 5 Wrong Input: 4f Input: 30 / 6 Output: 30 / 6 = 5","title":"Practical 10: Exception Handling"},{"location":"lab10/#practical-10-exception-handling","text":"Unfortunately, we live in a tragic society where there exist individuals who are fascinated with breaking stuff, and those who would rather fight for the right to do whatever they so please. This is no different with programs, but this is one way on how bugs are discovered in programs. In this practical, let's start playing the devil's advocate and do all we can to patch such problems. Who says that there is absolutely nothing that can be done to prevent their actions from affecting others? Java provides Exception classes that can be used to cater for unintended occurrences. While utilizing Exceptions are always welcome, one should try to resort to using simpler tactics whenever possible (e.g., implementing checks with if-else statements). It is also worth noting that for some languages, utilizing exception handling is not strongly encouraged.","title":"Practical 10: Exception Handling"},{"location":"lab10/#activity-applying-exception-handling-into-a-program","text":"Let's revisit that Staff program we just around to developing these past three practical sessions. We'll begin with the abstract parent class AcademicStaff.java .","title":"Activity: Applying Exception Handling into a Program"},{"location":"lab10/#academicstaffjava","text":"AcademicStaff.java has attributes fullName , id , and qualificationLevel . From the way we've implemented the qualificationLevel attribute, it can take one of 3 values: 1 (Bachelor), 2 (Master), or 3 (Doctorate). Let's make it such that when initializing an AcademicStaff object, it throws an Exception when any other value is received for qualificationLevel (not that it can now since it's abstract, but it will do the same for the subclasses). We will now modify the mutator method for this attribute like as follows: 1 2 3 4 5 6 public void setQualificationLevel ( int qualificationLevel ) { if ( qualificationLevel < 1 || qualificationLevel > 3 ) throw new IllegalArgumentException ( \"Qualification Level must be either 1, 2, or 3!\" ); this . qualificationLevel = qualificationLevel ; } Here, we are throwing an IllegalArgumentExcpetion back to the method that called it. The IllegalArgumentExcpetion class is one of many exception classes that exist in Java. This one in particular is best used here since we can regard a qualification level which is not one of the stated values (i.e., 1-3) as an illegal argument/value.","title":"AcademicStaff.java"},{"location":"lab10/#fulltimestaffjava","text":"The rank attribute follows the same convention as with the AcademicStaff 's qualificationLevel attribute. 1 2 3 4 5 6 public void setRank ( int rank ) { if ( rank < 1 || rank > 3 ) throw new IllegalArgumentException ( \"Rank must be either 1, 2, or 3!\" ); this . rank = rank ; } For both the contributionHours and baseSalary attributes, they are expected to contain non-negative values. We can proceed to throw an exception each time a negative value is entered, or we can set it to 0 instead (this does not require throwing an Exception, rather to implement an if-else statement). The choice is entirely up to you.","title":"FullTimeStaff.java"},{"location":"lab10/#throwing-an-exception","text":"1 2 3 4 5 6 public void setContributionHours ( int contributionHours ) { if ( contributionHours < 0 ) throw new IllegalArgumentException ( \"Contribution hours cannot be negative!\" ); this . contributionHours = contributionHours ; } 1 2 3 4 5 6 public void setBaseSalary ( int baseSalary ) { if ( baseSalary < 0 ) throw new IllegalArgumentException ( \"Base salary cannot be negative!\" ); this . baseSalary = baseSalary ; }","title":"Throwing an Exception"},{"location":"lab10/#defaulting-to-0","text":"1 2 3 4 5 6 public void setContributionHours ( int contributionHours ) { if ( contributionHours < 0 ) this . contributionHours = 0 ; else this . contributionHours = contributionHours ; } 1 2 3 4 5 6 public void setBaseSalary ( int baseSalary ) { if ( baseSalary < 0 ) this . baseSalary = 0 ; else this . baseSalary = baseSalary ; }","title":"Defaulting to 0"},{"location":"lab10/#parttimestaffjava","text":"The same approaches to FullTimeStaff 's attributes can be done for PartTimeStaff 's hourlyRate and hoursWorked attributes. Simply modify their mutator methods to work similarly. Apart from these mutator methods, we can also modify the addHoursWorked() method such that it will not take in negative values. In this case, reverting the hoursWorked value is not appropriate. Thus, you should throw an IllegalArgumentException object instead in its place.","title":"PartTimeStaff.java"},{"location":"lab10/#forcing-constructors-to-use-modified-mutator-methods","text":"Let's now modify the constructors in this class as well as the two subclasses such that they use the mutator methods by default when called. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { setFullName ( fullName ); setId ( id ); setQualificationLevel ( qualificationLevel ); } /* ... */ } FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { super ( fullName , id , qualificationLevel ); setRank ( rank ); setContributionHours ( contributionHours ); setBaseSalary ( baseSalary ); } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); setRank ( rank ); setContributionHours ( contributionHours ); switch ( this . rank ) { case 1 : setBaseSalary ( 2000 ); break ; case 2 : setBaseSalary ( 2500 ); break ; case 3 : setBaseSalary ( 3000 ); break ; default : setBaseSalary ( 0 ); } } public FullTimeStaff ( PartTimeStaff pt , int rank , int contributionHours ) { this ( pt . getFullName (), pt . getId (), pt . getQualificationLevel (), rank , contributionHours ); } /* ... */ } PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); setHourlyRate ( hourlyRate ); setHoursWorked ( hoursWorked ); } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); setHourlyRate ( hourlyRate ); setHoursWorked ( 0 ); } public PartTimeStaff ( FullTimeStaff ft , double hourlyRate ) { this ( ft . getFullName (), ft . getId (), ft . getQualificationLevel (), hourlyRate ); } /* ... */ }","title":"Forcing Constructors to Use Modified Mutator Methods"},{"location":"lab10/#try-catch-finally-block","text":"We've implemented the classes such that they throw the appropriate Exception classes as and when necessary. However, without specifying a method of catching such Exception classes, your program will not terminate gracefully. In the driver class' main method, surround your code with the try-catch block as follows: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Driver { public static void main ( String [] args ) { try { /* testing code goes here */ } catch ( IllegalArgumentException ex ) { System . out . println ( ex . getMessage ()); } catch ( Exception ex ) { ex . printStackTrace (); } } } The program is now set to check for Exception objects being thrown from anything that is called from the try block. Once the matching Exception object is caught, the program proceeds to run the statements from within that catch block. Whatever statements yet to be run from the try block is skipped. Notice that the program checks for an IllegalArgumentException object first before a more generic Exception object. In practice, you should cater to catch specific Exception types before ending with checking for objects of the generic Exception class. Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Driver { public static void main ( String [] args ) { try { /* testing code goes here */ } catch ( IllegalArgumentException ex ) { System . out . println ( ex . getMessage ()); } catch ( Exception ex ) { ex . printStackTrace (); } finally { System . out . println ( \"End of Staff program\" ); } } } Regardless of whether an Exception is caught, if a finally block exists, all statements from this block is run. Statements in the finally block can be used to close resources (e.g., for writing to files) or display specific messages (e.g., to signal the end of the program). Now, go bonkers and see if your attempts at securing your program a little better worked!","title":"try-catch-finally block"},{"location":"lab10/#tasks","text":"","title":"Tasks"},{"location":"lab10/#task-1","text":"Write a program that prompts the user to read two integers and displays their multiplication. Your program should prompt the user to read the number again if the input is incorrect. Example Output: Enter two integers: 3 a Incorrect input! Re-enter two integers: a 3 Incorrect input! Re-enter two integers: 3 3 Multiplication is 9","title":"Task 1"},{"location":"lab10/#task-2","text":"Write a program that meets the following requirements: Create an array with 100 randomly chosen integers. Prompt the user to enter the array index, then display the corresponding element value. If the specified index is out of bounds, display the message \"Index out of bounds\". Example Output: Enter an index: 101 Index out of bounds Enter an index: 55 The element is 7313 Enter an index: 108 Index out of bounds","title":"Task 2"},{"location":"lab10/#task-3","text":"Write a class named TestScores . The class constructor should accept any array of test scores as its argument. The class should have a method that returns the average of the test scores. If any test score in the array is negative or greater than 100 then the class should throw an IllegialArugumentException with the specified detail message to its caller. Demonstrate the usage of the class in a test program.","title":"Task 3"},{"location":"lab10/#task-4","text":"Write a program that uses the following method to solve equations specified by the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Returns the larger of the two roots of * the quadratic equation A*x*x + B*x + C = 0. * (Throws an exception if A == 0 or B*B-4*A*C < 0.) */ public static double root ( double A , double B , double C ) throws IllegalArgumentException { if ( A == 0 ) { throw new IllegalArgumentException ( \"A can't be zero.\" ); } else { double disc = B * B - 4 * A * C ; if ( disc < 0 ) throw new IllegalArgumentException ( \"Discriminant < zero.\" ); return ( - B + Math . sqrt ( disc )) / ( 2 * A ); } } Your program should allow the user to specify values for A , B , and C . It should call the method to compute a solution of the equation. If no error occurs, it should print the root. However, if an error occurs, your program should catch that error and print an error message. After processing one equation, the program should ask whether the user wants to enter another equation. The program should continue until the user answers no.","title":"Task 4"},{"location":"lab10/#optional-task-challenge-question","text":"Write a calculator program. The program terminates if any operand is non-numeric. Write a program with an exception handler that deals with non-numeric operands; then write another program without using an exception handler to achieve the same objective. Your program should display a message that informs the user of the wrong operand type before exiting. Example Output: Input: 5 + y Wrong Input: y Input: 4f x 5 Wrong Input: 4f Input: 30 / 6 Output: 30 / 6 = 5","title":"Optional Task (Challenge Question)"},{"location":"lab11/","text":"Practical 11: File I/O A useful application of classes and exception handling in Java is File I/O. In this practical activity, we will utilize classes specifically meant to carry out file I/O with text files. Tasks Task 1 Write a program that reads from Exercise1.txt and counts the number of characters, words, and lines in a file. Words are separated by whitespace characters. Exercise1.txt Task 2 Suppose that a text file (Exercise2.txt) contains an unspecified number of scores separated by blanks. Write a program that prompts the user to enter the file, reads the scores from the file, and displays their total and average. Exercise2.txt Task 3 Write a program that creates a file named Exercise3.txt if it does not already exist. Write 100 randomly generated integers into this file using text I/O. Integers are to be separated by spaces in the file. Read the data back from the file and display the data in increasing order. Task 4 Write a program that prompts the user to enter a file name and displays the occurrences of each letter in the file. Letters are case-insensitive. Here is a sample run: Enter file name: Exercise1.txt The occurrence of A's is 22 The occurrence of B's is 6 The occurrence of C's is 4 The occurrence of D's is 6 The occurrence of E's is 28 The occurrence of F's is 4 The occurrence of G's is 1 The occurrence of H's is 3 The occurrence of I's is 5 The occurrence of J's is 14 The occurrence of K's is 2 The occurrence of L's is 7 The occurrence of M's is 6 The occurrence of N's is 4 The occurrence of O's is 7 The occurrence of P's is 4 The occurrence of Q's is 0 The occurrence of R's is 15 The occurrence of S's is 16 The occurrence of T's is 5 The occurrence of U's is 6 The occurrence of V's is 6 The occurrence of W's is 1 The occurrence of X's is 0 The occurrence of Y's is 7 The occurrence of Z's is 0","title":"Practical 11: File I/O"},{"location":"lab11/#practical-11-file-io","text":"A useful application of classes and exception handling in Java is File I/O. In this practical activity, we will utilize classes specifically meant to carry out file I/O with text files.","title":"Practical 11: File I/O"},{"location":"lab11/#tasks","text":"","title":"Tasks"},{"location":"lab11/#task-1","text":"Write a program that reads from Exercise1.txt and counts the number of characters, words, and lines in a file. Words are separated by whitespace characters. Exercise1.txt","title":"Task 1"},{"location":"lab11/#task-2","text":"Suppose that a text file (Exercise2.txt) contains an unspecified number of scores separated by blanks. Write a program that prompts the user to enter the file, reads the scores from the file, and displays their total and average. Exercise2.txt","title":"Task 2"},{"location":"lab11/#task-3","text":"Write a program that creates a file named Exercise3.txt if it does not already exist. Write 100 randomly generated integers into this file using text I/O. Integers are to be separated by spaces in the file. Read the data back from the file and display the data in increasing order.","title":"Task 3"},{"location":"lab11/#task-4","text":"Write a program that prompts the user to enter a file name and displays the occurrences of each letter in the file. Letters are case-insensitive. Here is a sample run: Enter file name: Exercise1.txt The occurrence of A's is 22 The occurrence of B's is 6 The occurrence of C's is 4 The occurrence of D's is 6 The occurrence of E's is 28 The occurrence of F's is 4 The occurrence of G's is 1 The occurrence of H's is 3 The occurrence of I's is 5 The occurrence of J's is 14 The occurrence of K's is 2 The occurrence of L's is 7 The occurrence of M's is 6 The occurrence of N's is 4 The occurrence of O's is 7 The occurrence of P's is 4 The occurrence of Q's is 0 The occurrence of R's is 15 The occurrence of S's is 16 The occurrence of T's is 5 The occurrence of U's is 6 The occurrence of V's is 6 The occurrence of W's is 1 The occurrence of X's is 0 The occurrence of Y's is 7 The occurrence of Z's is 0","title":"Task 4"},{"location":"archive/202108/","text":"ITS42004 Object-Oriented Programming This site hosts the practical lab work for ITS42004: Object-Oriented Programming, offered by the School of Pre-University Studies at Taylor's College. Aim The aim of these practical lab exercises is to guide the students through programming in an object-oriented paradigm. Schedule (August 2021 Semester) The schedule is subject to change. Week Lecture Practical Lab 1 23 Aug - 27 Aug Introduction to Java Practical Preparation 2 30 Aug - 3 Sept Fundamentals of Java Structure Practical 1 3 6 Sept - 10 Sept Program Control Structure (Part 1): Selection Statements Practical 2 4 13 Sept - 17 Sept Program Control Structure (Part 2): Loop Statements Practical 3 5 20 Sept - 24 Sept Arrays and ArrayList Practical 4 6 27 Sept - 1 Oct Methods Practical 5 7 4 Oct - 8 Oct OOP Principles (Part 1): Designing Classes Practical 6 8 11 Oct - 15 Oct OOP Principles (Part 2): Inheritance Practical 7 9 18 Oct - 22 Oct OOP Principles (Part 3): Polymorphism Practical 8 10 25 Oct - 29 Oct OOP Principles (Part 4): Abstract Classes & Interfaces Practical Test 11 1 Nov - 5 Nov Independent Learning Week Practical 9 12 8 Nov - 12 Nov Exception Handling Practical 10 13 15 Nov - 19 Nov File I/O Practical 11 14 22 Nov - 26 Nov Wrap-up Lecture and FE Briefing Note The practical work is arranged such that it complements the respective weeks' lectures. It is encouraged that you ensure that you're familiar with the lecture content before attempting the practical work.","title":"Home"},{"location":"archive/202108/#aim","text":"The aim of these practical lab exercises is to guide the students through programming in an object-oriented paradigm.","title":"Aim"},{"location":"archive/202108/#schedule-august-2021-semester","text":"The schedule is subject to change. Week Lecture Practical Lab 1 23 Aug - 27 Aug Introduction to Java Practical Preparation 2 30 Aug - 3 Sept Fundamentals of Java Structure Practical 1 3 6 Sept - 10 Sept Program Control Structure (Part 1): Selection Statements Practical 2 4 13 Sept - 17 Sept Program Control Structure (Part 2): Loop Statements Practical 3 5 20 Sept - 24 Sept Arrays and ArrayList Practical 4 6 27 Sept - 1 Oct Methods Practical 5 7 4 Oct - 8 Oct OOP Principles (Part 1): Designing Classes Practical 6 8 11 Oct - 15 Oct OOP Principles (Part 2): Inheritance Practical 7 9 18 Oct - 22 Oct OOP Principles (Part 3): Polymorphism Practical 8 10 25 Oct - 29 Oct OOP Principles (Part 4): Abstract Classes & Interfaces Practical Test 11 1 Nov - 5 Nov Independent Learning Week Practical 9 12 8 Nov - 12 Nov Exception Handling Practical 10 13 15 Nov - 19 Nov File I/O Practical 11 14 22 Nov - 26 Nov Wrap-up Lecture and FE Briefing Note The practical work is arranged such that it complements the respective weeks' lectures. It is encouraged that you ensure that you're familiar with the lecture content before attempting the practical work.","title":"Schedule (August 2021 Semester)"},{"location":"archive/202108/lab00/","text":"Practical Preparation Integrated Development Environment (IDE) Going forward, I will be using IntelliJ IDEA by Jetbrains as my IDE of choice during demos. However, this is not the only choice available - some good alternatives include Eclipse, Netbeans, and Visual Studio Code. Of course, you are not forbidden to use a different code editor you're already familiar with, as long as you are able to write Java programs with it. Installing Java JDK Before installing the IDE of your choice, you will need to install the Java Development Kit (JDK) first. Here are some video tutorials on how to install the JDK in your machine. How to Install JDK for Amazon Corretto for Windows How to Install JDK for Amazon Corretto for macOS How to Install JDK for Amazon Corretto on Linux Setting Up IntelliJ IDEA As mentioned earlier, the program I will be using is IntelliJ IDEA. Here are some video tutorials on how to install IntelliJ IDEA in your machine. How to Install IntelliJ in Windows How to Install IntelliJ in macOS How to Install IntelliJ in Linux Upon installing IntelliJ IDEA in your machine, there are a few configurations you will need to carry out before starting to use IntelliJ IDEA. The following video tutorial will help you get to speed in setting up IntelliJ IDEA before starting to program. IntelliJ Configuration on Mac, Linux and Windows Testing IntelliJ IDEA Create different Java files to contain each of the following code snippets. Ensure that the code runs properly. Demo1 public class Demo1 { public static void main ( String [] args ) { System . out . println ( \"Welcome \" ); System . out . println ( \"To \" ); System . out . println ( \"OOP Class\" ); } } Demo2 public class Demo2 { public static void main ( String [] args ) { System . out . println ( \"3.5 * 4 / 2 - 2.5 is \" ); System . out . println ( 3.5 * 4 / 2 - 2.5 ); } }","title":"Practical Preparation"},{"location":"archive/202108/lab00/#practical-preparation","text":"","title":"Practical Preparation"},{"location":"archive/202108/lab00/#integrated-development-environment-ide","text":"Going forward, I will be using IntelliJ IDEA by Jetbrains as my IDE of choice during demos. However, this is not the only choice available - some good alternatives include Eclipse, Netbeans, and Visual Studio Code. Of course, you are not forbidden to use a different code editor you're already familiar with, as long as you are able to write Java programs with it.","title":"Integrated Development Environment (IDE)"},{"location":"archive/202108/lab00/#installing-java-jdk","text":"Before installing the IDE of your choice, you will need to install the Java Development Kit (JDK) first. Here are some video tutorials on how to install the JDK in your machine. How to Install JDK for Amazon Corretto for Windows How to Install JDK for Amazon Corretto for macOS How to Install JDK for Amazon Corretto on Linux","title":"Installing Java JDK"},{"location":"archive/202108/lab00/#setting-up-intellij-idea","text":"As mentioned earlier, the program I will be using is IntelliJ IDEA. Here are some video tutorials on how to install IntelliJ IDEA in your machine. How to Install IntelliJ in Windows How to Install IntelliJ in macOS How to Install IntelliJ in Linux Upon installing IntelliJ IDEA in your machine, there are a few configurations you will need to carry out before starting to use IntelliJ IDEA. The following video tutorial will help you get to speed in setting up IntelliJ IDEA before starting to program. IntelliJ Configuration on Mac, Linux and Windows","title":"Setting Up IntelliJ IDEA"},{"location":"archive/202108/lab00/#testing-intellij-idea","text":"Create different Java files to contain each of the following code snippets. Ensure that the code runs properly.","title":"Testing IntelliJ IDEA"},{"location":"archive/202108/lab00/#demo1","text":"public class Demo1 { public static void main ( String [] args ) { System . out . println ( \"Welcome \" ); System . out . println ( \"To \" ); System . out . println ( \"OOP Class\" ); } }","title":"Demo1"},{"location":"archive/202108/lab00/#demo2","text":"public class Demo2 { public static void main ( String [] args ) { System . out . println ( \"3.5 * 4 / 2 - 2.5 is \" ); System . out . println ( 3.5 * 4 / 2 - 2.5 ); } }","title":"Demo2"},{"location":"archive/202108/lab01/","text":"Practical 01: Getting Started with Java This practical will serve as a starting point to getting used to programming in Java. However, all object-oriented programming concepts learnt in this module can also be applied into other object-oriented programming languages like C#, or other languages that have support for it like PHP. Java is only considered a fully object-oriented programming language that's a good starting language to use to learn such concepts. Tasks Task 1 Create a program with a new class called FirstJava which produces the following output: This is my first attempt to program in Java It works! Modify the source code such that it produces the following output: This is my first attempt to program in Java It works! Task 2 Identify and fix the errors in the following source codes. Program 1 public class Practical1 { public static void main ( String [] args ) { System . out . println ( ' Welcome to Java ! ); } } Program 2 public class Test { public void main ( string [] args ) { double i = 50.0 ; double k = i + 50.0 ; double j = k + 1 ; System . out . println ( \"j is \" + j + \" and k is \" + k ); } } Task 3 Copy and run the following source code. The expected output should be as follows: Modify the source code such that it computes the circumference of a circle instead. Formula: circumference = 2 * radius * pi Task 4 Write a Java program to calculate the area and perimeter of a rectangle when the user inputs the width and height using the following formula (display the output in 2 decimal places): area = width * height Task 5 Write a program that displays the current GMT time in the format hour:time:second (e.g., 1:45:19 ). Task 6 Write a program that converts pounds into kilograms. The program should prompt the user to enter a number in pounds, convert it to kilograms and display the result. Assume 1 pound is equal to 0.454 kilograms. Task 7 Write a program that converts MYR to USD. The program should prompt the user to enter a double value in MYR, convert it to USD and display the result. Look up online for the latest exchange rate and ensure the currency is displayed in 2 decimal places (as with most currency formats, this rule is a must). Task 8 Write a program that reads the subtotal and gratuity rate, then computes the gratuity and total. For example, if the user enters 10 for subtotal and 15% for gratuity rate, the program displays $1.50 as gratuity and $11.50 as the total.","title":"Practical 01: Getting Started with Java"},{"location":"archive/202108/lab01/#practical-01-getting-started-with-java","text":"This practical will serve as a starting point to getting used to programming in Java. However, all object-oriented programming concepts learnt in this module can also be applied into other object-oriented programming languages like C#, or other languages that have support for it like PHP. Java is only considered a fully object-oriented programming language that's a good starting language to use to learn such concepts.","title":"Practical 01: Getting Started with Java"},{"location":"archive/202108/lab01/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab01/#task-1","text":"Create a program with a new class called FirstJava which produces the following output: This is my first attempt to program in Java It works! Modify the source code such that it produces the following output: This is my first attempt to program in Java It works!","title":"Task 1"},{"location":"archive/202108/lab01/#task-2","text":"Identify and fix the errors in the following source codes.","title":"Task 2"},{"location":"archive/202108/lab01/#program-1","text":"public class Practical1 { public static void main ( String [] args ) { System . out . println ( ' Welcome to Java ! ); } }","title":"Program 1"},{"location":"archive/202108/lab01/#program-2","text":"public class Test { public void main ( string [] args ) { double i = 50.0 ; double k = i + 50.0 ; double j = k + 1 ; System . out . println ( \"j is \" + j + \" and k is \" + k ); } }","title":"Program 2"},{"location":"archive/202108/lab01/#task-3","text":"Copy and run the following source code. The expected output should be as follows: Modify the source code such that it computes the circumference of a circle instead. Formula: circumference = 2 * radius * pi","title":"Task 3"},{"location":"archive/202108/lab01/#task-4","text":"Write a Java program to calculate the area and perimeter of a rectangle when the user inputs the width and height using the following formula (display the output in 2 decimal places): area = width * height","title":"Task 4"},{"location":"archive/202108/lab01/#task-5","text":"Write a program that displays the current GMT time in the format hour:time:second (e.g., 1:45:19 ).","title":"Task 5"},{"location":"archive/202108/lab01/#task-6","text":"Write a program that converts pounds into kilograms. The program should prompt the user to enter a number in pounds, convert it to kilograms and display the result. Assume 1 pound is equal to 0.454 kilograms.","title":"Task 6"},{"location":"archive/202108/lab01/#task-7","text":"Write a program that converts MYR to USD. The program should prompt the user to enter a double value in MYR, convert it to USD and display the result. Look up online for the latest exchange rate and ensure the currency is displayed in 2 decimal places (as with most currency formats, this rule is a must).","title":"Task 7"},{"location":"archive/202108/lab01/#task-8","text":"Write a program that reads the subtotal and gratuity rate, then computes the gratuity and total. For example, if the user enters 10 for subtotal and 15% for gratuity rate, the program displays $1.50 as gratuity and $11.50 as the total.","title":"Task 8"},{"location":"archive/202108/lab02/","text":"Practical 02: Selection Statements We will now proceed with implementing selection statements in this practical. Selection statements in Java include the if-else statement, and the switch statement. Tasks Task 1 Write a lottery program that randomly generates a two-digit number (10-99), prompts the user to enter another two-digit number (also 10-99), and determines what the user wins according to the following rules: If the user input exactly matches the randomly generated lottery number, the reward is $10,000. If the user input has both numbers used in the generated lottery number, the reward is $3,000. If any one of the digits in the user input matches one of the digits used in the generated lottery number, the reward is $1,000. Give no reward otherwise. Task 2 Write a program that prompts the user to enter a year and display the Chinese zodiac animal that corresponds with the given remainder after dividing by 12: Remainder Chinese Zodiac Animal Remainder Chinese Zodiac Animal 0 Monkey 6 Tiger 1 Rooster 7 Rabbit 2 Dog 8 Dragon 3 Pig 9 Snake 4 Rat 10 Horse 5 Ox 11 Sheep Task 3 The Body Mass Index (BMI) is a measure of health on weight. A person's BMI is calculated by taking the person's weight (in kilograms) divided by the person's height squared (height in meters). Create a BMI program that takes in both a person's weight and height as values to interpret the person's BMI. The respective BMI interpretations are as follows: BMI Interpretation BMI < 18.5 Underweight 18.5 \u2264 BMI < 25.0 Normal 25.0 \u2264 BMI < 30.0 Overweight BMI \u2265 30.0 Obese Task 4 The personal income tax is calculated based on the filing status and taxable income. There are four filing statuses: single filers, married filing jointly, married filing separately, and head of household. The tax rates are as shown below. Create a program that prompts users to input their filing status and taxable income to calculate the required tax payment for the year. Task 5 Write a program to calculate the electricity bill with the rates as follows: Consumed Units Rate ($) 1-50 1.15 51-100 2.60 101-150 3.55 151-200 4.50 201-300 5.90 301-400 6.90 401-500 7.90 501-1000 8.90 >1000 10.99 Sample Output: Enter Previous Month Reading: 180 Enter Current Month Reading: 275 Total Units Consumed: 95 Total Bill: $174.50 Hint (50 * 1.15) + (45 * 2.60)","title":"Practical 02: Selection Statements"},{"location":"archive/202108/lab02/#practical-02-selection-statements","text":"We will now proceed with implementing selection statements in this practical. Selection statements in Java include the if-else statement, and the switch statement.","title":"Practical 02: Selection Statements"},{"location":"archive/202108/lab02/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab02/#task-1","text":"Write a lottery program that randomly generates a two-digit number (10-99), prompts the user to enter another two-digit number (also 10-99), and determines what the user wins according to the following rules: If the user input exactly matches the randomly generated lottery number, the reward is $10,000. If the user input has both numbers used in the generated lottery number, the reward is $3,000. If any one of the digits in the user input matches one of the digits used in the generated lottery number, the reward is $1,000. Give no reward otherwise.","title":"Task 1"},{"location":"archive/202108/lab02/#task-2","text":"Write a program that prompts the user to enter a year and display the Chinese zodiac animal that corresponds with the given remainder after dividing by 12: Remainder Chinese Zodiac Animal Remainder Chinese Zodiac Animal 0 Monkey 6 Tiger 1 Rooster 7 Rabbit 2 Dog 8 Dragon 3 Pig 9 Snake 4 Rat 10 Horse 5 Ox 11 Sheep","title":"Task 2"},{"location":"archive/202108/lab02/#task-3","text":"The Body Mass Index (BMI) is a measure of health on weight. A person's BMI is calculated by taking the person's weight (in kilograms) divided by the person's height squared (height in meters). Create a BMI program that takes in both a person's weight and height as values to interpret the person's BMI. The respective BMI interpretations are as follows: BMI Interpretation BMI < 18.5 Underweight 18.5 \u2264 BMI < 25.0 Normal 25.0 \u2264 BMI < 30.0 Overweight BMI \u2265 30.0 Obese","title":"Task 3"},{"location":"archive/202108/lab02/#task-4","text":"The personal income tax is calculated based on the filing status and taxable income. There are four filing statuses: single filers, married filing jointly, married filing separately, and head of household. The tax rates are as shown below. Create a program that prompts users to input their filing status and taxable income to calculate the required tax payment for the year.","title":"Task 4"},{"location":"archive/202108/lab02/#task-5","text":"Write a program to calculate the electricity bill with the rates as follows: Consumed Units Rate ($) 1-50 1.15 51-100 2.60 101-150 3.55 151-200 4.50 201-300 5.90 301-400 6.90 401-500 7.90 501-1000 8.90 >1000 10.99 Sample Output: Enter Previous Month Reading: 180 Enter Current Month Reading: 275 Total Units Consumed: 95 Total Bill: $174.50 Hint (50 * 1.15) + (45 * 2.60)","title":"Task 5"},{"location":"archive/202108/lab03/","text":"Practical 03: Loop Statements Loop structures make up the remaining part of program control structures. We will be implementing loop structures (i.e., for loop, while loop, do-while loop) in this practical. Activity: for Loops vs. while Loops vs. do-while Loops The following shows a for loop which iterates from 0 to 7, adding each iterated number into a variable called sum . int sum = 0 ; for ( int i = 0 ; i <= 7 ; i ++ ) { sum = sum + i ; } Add a line within the loop to print out the value of sum during each iteration. Convert the given for loop into a while loop and do-while loop. Is there a difference in terms of output between these two loop types? Convert the following for loop into a while loop and do-while loop. Is there a difference in terms of output between these two loop types? int sum = 0 ; for ( int i = 7 ; i < 7 ; i ++ ) { sum = sum + i ; System . out . println ( \"Value of sum: \" + sum ); } Tasks Task 1 Suppose that the tuition fees for a university program is $10,000 this year. It is expected that the tuition fees increase by 7% per year. Write a program that will estimate how long (in years) it will take for the tuition fees amount to be double of this year's amount. Task 2 Every day, a weather station receives 5 temperatures expressed in degrees Farenheit. Write a program that will accept 5 Farenheit temperatures, and display the temperature expressed in Celsius on screen. After 5 temperatures have been processed, output the message \"All Temperatures Processed\". Conversion Formula: Celsius = (Farenheit - 32) * 5 / 9 Sample Output: Farenheit Temperature #1: 67 67.00 degrees Farenheit is 19.44 degrees Celsius. Farenheit Temperature #2: 89 89.00 degrees Farenheit is 31.67 degrees Celsius. Farenheit Temperature #3: 34 67.00 degrees Farenheit is 1.11 degrees Celsius. Farenheit Temperature #2: 67 89.00 degrees Farenheit is 19.44 degrees Celsius. Farenheit Temperature #5: 34 89.00 degrees Farenheit is 1.1 degrees Celsius. All Temperatures Processed Task 3 Write a program that prompts the user to enter a 3-digit integer and determines whether it is a palindrome integer. An integer is a palindrome if it reads the same from right to left and left to right. A negative integer is treated the same as a positive integer. Here are sample runs of this program: Task 4 Write a program that displays the first 50 prime numbers in five lines, each of which contains 10 numbers. An integer greater than 1 is prime if its only positive divisor is 1 or itself. For example, 2, 3, 5 and 7 are prime numbers, but 4, 6, 8 and 9 are not. Hint For each number (2, 3, 4, ...), determine whether a given number is prime. The shortcut is to see if the current number is divsible by any number up to half its value. Once a prime number is found, print out the prime number followed by a space. // ... for ( int divisor = 2 ; divisor < ( iter / 2 ); divisor ++ ) { // shortcut is in here // if current number in iteration is divisible by divisor that's not 1 or the same number as itself if ( iter % divisor == 0 ) { isPrime = false ; break ; } } // ... Have a counter value that counts up to 50 each time a prime number is found. When the counter hits a multiple of 10, print a newline character. When the counter value hits 50, stop the program. Task 5 Write a program that reads an integer between 0 and 1000 and adds all the digits in the integer. For example, if an integer is 932, the sum of all digits is 14. Sample output: Enter a number between 0 and 1000: 999 The sum of digits is 27. Hint Use the % operator to extract digits and use the / operator to remove the extracted digit. For instance, 932 % 10 = 2 and 932 / 10 = 93 . Task 6 Construct a calculator program that takes in 2 integer variables and performs one of the following mathematical operations by choice: addition, subtraction, multiplication, division, and modulo (the remainder function). Include a selection menu to prompt the user to select the desired mathematical operation.","title":"Practical 03: Loop Statements"},{"location":"archive/202108/lab03/#practical-03-loop-statements","text":"Loop structures make up the remaining part of program control structures. We will be implementing loop structures (i.e., for loop, while loop, do-while loop) in this practical.","title":"Practical 03: Loop Statements"},{"location":"archive/202108/lab03/#activity-for-loops-vs-while-loops-vs-do-while-loops","text":"The following shows a for loop which iterates from 0 to 7, adding each iterated number into a variable called sum . int sum = 0 ; for ( int i = 0 ; i <= 7 ; i ++ ) { sum = sum + i ; } Add a line within the loop to print out the value of sum during each iteration. Convert the given for loop into a while loop and do-while loop. Is there a difference in terms of output between these two loop types? Convert the following for loop into a while loop and do-while loop. Is there a difference in terms of output between these two loop types? int sum = 0 ; for ( int i = 7 ; i < 7 ; i ++ ) { sum = sum + i ; System . out . println ( \"Value of sum: \" + sum ); }","title":"Activity: for Loops vs. while Loops vs. do-while Loops"},{"location":"archive/202108/lab03/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab03/#task-1","text":"Suppose that the tuition fees for a university program is $10,000 this year. It is expected that the tuition fees increase by 7% per year. Write a program that will estimate how long (in years) it will take for the tuition fees amount to be double of this year's amount.","title":"Task 1"},{"location":"archive/202108/lab03/#task-2","text":"Every day, a weather station receives 5 temperatures expressed in degrees Farenheit. Write a program that will accept 5 Farenheit temperatures, and display the temperature expressed in Celsius on screen. After 5 temperatures have been processed, output the message \"All Temperatures Processed\". Conversion Formula: Celsius = (Farenheit - 32) * 5 / 9 Sample Output: Farenheit Temperature #1: 67 67.00 degrees Farenheit is 19.44 degrees Celsius. Farenheit Temperature #2: 89 89.00 degrees Farenheit is 31.67 degrees Celsius. Farenheit Temperature #3: 34 67.00 degrees Farenheit is 1.11 degrees Celsius. Farenheit Temperature #2: 67 89.00 degrees Farenheit is 19.44 degrees Celsius. Farenheit Temperature #5: 34 89.00 degrees Farenheit is 1.1 degrees Celsius. All Temperatures Processed","title":"Task 2"},{"location":"archive/202108/lab03/#task-3","text":"Write a program that prompts the user to enter a 3-digit integer and determines whether it is a palindrome integer. An integer is a palindrome if it reads the same from right to left and left to right. A negative integer is treated the same as a positive integer. Here are sample runs of this program:","title":"Task 3"},{"location":"archive/202108/lab03/#task-4","text":"Write a program that displays the first 50 prime numbers in five lines, each of which contains 10 numbers. An integer greater than 1 is prime if its only positive divisor is 1 or itself. For example, 2, 3, 5 and 7 are prime numbers, but 4, 6, 8 and 9 are not. Hint For each number (2, 3, 4, ...), determine whether a given number is prime. The shortcut is to see if the current number is divsible by any number up to half its value. Once a prime number is found, print out the prime number followed by a space. // ... for ( int divisor = 2 ; divisor < ( iter / 2 ); divisor ++ ) { // shortcut is in here // if current number in iteration is divisible by divisor that's not 1 or the same number as itself if ( iter % divisor == 0 ) { isPrime = false ; break ; } } // ... Have a counter value that counts up to 50 each time a prime number is found. When the counter hits a multiple of 10, print a newline character. When the counter value hits 50, stop the program.","title":"Task 4"},{"location":"archive/202108/lab03/#task-5","text":"Write a program that reads an integer between 0 and 1000 and adds all the digits in the integer. For example, if an integer is 932, the sum of all digits is 14. Sample output: Enter a number between 0 and 1000: 999 The sum of digits is 27. Hint Use the % operator to extract digits and use the / operator to remove the extracted digit. For instance, 932 % 10 = 2 and 932 / 10 = 93 .","title":"Task 5"},{"location":"archive/202108/lab03/#task-6","text":"Construct a calculator program that takes in 2 integer variables and performs one of the following mathematical operations by choice: addition, subtraction, multiplication, division, and modulo (the remainder function). Include a selection menu to prompt the user to select the desired mathematical operation.","title":"Task 6"},{"location":"archive/202108/lab04/","text":"Practical 04: Arrays and ArrayLists Arrays allow for storing a series of values within one data structure. We will be working on implementing solutions that involve the use of arrays and ArrayList data structures in this practical. Tasks Task 1 Write a Java program that prompts for 10 integers. Print all the elements of the array in a single row, separated by spaces. Count and total up the negative numbers from the input. Count and total up the positive numbers from the input. Task 2 Write a Java program that prints the index of the smallest element in an array of integers. Sample arrays: [6, 33, 3, 63, 25, 1, 99] will return index 5 [10, -3, 55, -10, -24, 54, 0, -21, 8] will return index 4 Randomly generate 10 numbers between 0 and 100 for the first array. For the second array, randomly generate 10 numbers between -100 and 100. Task 3 Bubble sort works by swapping adjacent elements if they are not in the desired order. This process repeats from the beginning of the array until all elements are in order. Here are the steps for sorting an array of numbers from smallest to largest: FIRST ITERATION 4 2 1 5 3 : The first two elements are in the wrong order (i.e., 4 > 2), so we swap them. 2 4 1 5 3 : The second two elements are in the wrong order (i.e., 4 > 1) \u2192 swap. 2 1 4 5 3 : These two elements are in the right order (i.e., 4 < 5) \u2192 do nothing. 2 1 4 5 3 : Swap. 2 1 4 3 5 : Resulting array after first iteration. SECOND ITERATION 2 1 4 3 5 : Wrong order (i.e., 2 > 1) \u2192 swap. 1 2 4 3 5 : Right order (i.e., 2 < 4) \u2192 do nothing. 1 2 4 3 5 : Wrong order (i.e., 4 > 3) \u2192 swap. 1 2 3 4 5 : Resulting array after first iteration. THIRD ITERATION 1 2 3 4 5 : Right order (i.e., 1 < 2) \u2192 do nothing. 1 2 3 4 5 : Right order (i.e., 2 < 3) \u2192 do nothing. 1 2 3 4 5 : Resulting array after first iteration. You may try out your algorithm with the following sample arrays: [6, 32, 7, 2, 99, 31, 53] [-1, -23, -5, -75, -21, -43, -15] [6, 21, -43, 12, 75, -32, -6] Array of 10 randomly generated numbers (between 0 and 100) Task 4 Suppose the weekly hours for all employees are stored in a two-dimensional array. Each row records an employee's seven-day work hours with seven columns. For example, the following array stores the work hours for eight employees. Write a program that displays employees and their total hours worked. Initialize the array with the values shown in the following table. Sun Mon Tues Wed Thur Fri Sat Employee 0 2 4 3 4 5 8 8 Employee 1 7 3 4 3 3 4 4 Employee 2 3 3 4 3 3 2 2 Employee 3 9 3 4 7 3 4 1 Employee 4 3 5 4 3 6 3 8 Employee 5 3 4 4 6 3 4 4 Employee 6 3 7 4 8 3 8 4 Employee 7 6 3 5 9 2 7 9 Sample Output: The total working hours in a week for Employee 0 is 34 hours Employee 1 is 28 hours Employee 2 is 20 hours Employee 3 is 31 hours Employee 4 is 32 hours Employee 5 is 28 hours Employee 6 is 37 hours Employee 7 is 41 hours Note Syntax for declaring and creating 2-dimensional arrays: dataType[][] variableName = new dataType[x][y]; Task 5 Write a Java program that reads an unspecified number of scores and determines how many scores are above or equal to the average and how many scores are below the average. Enter a negative number to signify the end of the input. Assume that the maximum number of scores that can be input is 10. Sample Output: Enter the scores (negative number to end) Score 1: 10 Score 2: 10 Score 3: 6 Score 4: 6 Score 5: 2 Score 6: -1 Results ======= Average is 6.8 Number of scores above or equal to the average is 2 NUmber of scores below the average is 3 Process completed.","title":"Practical 04: Arrays and ArrayLists"},{"location":"archive/202108/lab04/#practical-04-arrays-and-arraylists","text":"Arrays allow for storing a series of values within one data structure. We will be working on implementing solutions that involve the use of arrays and ArrayList data structures in this practical.","title":"Practical 04: Arrays and ArrayLists"},{"location":"archive/202108/lab04/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab04/#task-1","text":"Write a Java program that prompts for 10 integers. Print all the elements of the array in a single row, separated by spaces. Count and total up the negative numbers from the input. Count and total up the positive numbers from the input.","title":"Task 1"},{"location":"archive/202108/lab04/#task-2","text":"Write a Java program that prints the index of the smallest element in an array of integers. Sample arrays: [6, 33, 3, 63, 25, 1, 99] will return index 5 [10, -3, 55, -10, -24, 54, 0, -21, 8] will return index 4 Randomly generate 10 numbers between 0 and 100 for the first array. For the second array, randomly generate 10 numbers between -100 and 100.","title":"Task 2"},{"location":"archive/202108/lab04/#task-3","text":"Bubble sort works by swapping adjacent elements if they are not in the desired order. This process repeats from the beginning of the array until all elements are in order. Here are the steps for sorting an array of numbers from smallest to largest: FIRST ITERATION 4 2 1 5 3 : The first two elements are in the wrong order (i.e., 4 > 2), so we swap them. 2 4 1 5 3 : The second two elements are in the wrong order (i.e., 4 > 1) \u2192 swap. 2 1 4 5 3 : These two elements are in the right order (i.e., 4 < 5) \u2192 do nothing. 2 1 4 5 3 : Swap. 2 1 4 3 5 : Resulting array after first iteration. SECOND ITERATION 2 1 4 3 5 : Wrong order (i.e., 2 > 1) \u2192 swap. 1 2 4 3 5 : Right order (i.e., 2 < 4) \u2192 do nothing. 1 2 4 3 5 : Wrong order (i.e., 4 > 3) \u2192 swap. 1 2 3 4 5 : Resulting array after first iteration. THIRD ITERATION 1 2 3 4 5 : Right order (i.e., 1 < 2) \u2192 do nothing. 1 2 3 4 5 : Right order (i.e., 2 < 3) \u2192 do nothing. 1 2 3 4 5 : Resulting array after first iteration. You may try out your algorithm with the following sample arrays: [6, 32, 7, 2, 99, 31, 53] [-1, -23, -5, -75, -21, -43, -15] [6, 21, -43, 12, 75, -32, -6] Array of 10 randomly generated numbers (between 0 and 100)","title":"Task 3"},{"location":"archive/202108/lab04/#task-4","text":"Suppose the weekly hours for all employees are stored in a two-dimensional array. Each row records an employee's seven-day work hours with seven columns. For example, the following array stores the work hours for eight employees. Write a program that displays employees and their total hours worked. Initialize the array with the values shown in the following table. Sun Mon Tues Wed Thur Fri Sat Employee 0 2 4 3 4 5 8 8 Employee 1 7 3 4 3 3 4 4 Employee 2 3 3 4 3 3 2 2 Employee 3 9 3 4 7 3 4 1 Employee 4 3 5 4 3 6 3 8 Employee 5 3 4 4 6 3 4 4 Employee 6 3 7 4 8 3 8 4 Employee 7 6 3 5 9 2 7 9 Sample Output: The total working hours in a week for Employee 0 is 34 hours Employee 1 is 28 hours Employee 2 is 20 hours Employee 3 is 31 hours Employee 4 is 32 hours Employee 5 is 28 hours Employee 6 is 37 hours Employee 7 is 41 hours Note Syntax for declaring and creating 2-dimensional arrays: dataType[][] variableName = new dataType[x][y];","title":"Task 4"},{"location":"archive/202108/lab04/#task-5","text":"Write a Java program that reads an unspecified number of scores and determines how many scores are above or equal to the average and how many scores are below the average. Enter a negative number to signify the end of the input. Assume that the maximum number of scores that can be input is 10. Sample Output: Enter the scores (negative number to end) Score 1: 10 Score 2: 10 Score 3: 6 Score 4: 6 Score 5: 2 Score 6: -1 Results ======= Average is 6.8 Number of scores above or equal to the average is 2 NUmber of scores below the average is 3 Process completed.","title":"Task 5"},{"location":"archive/202108/lab05/","text":"Practical 05: Methods Aside from being able to modularize code, using methods is integral to when we start covering Classes and Objects in the next session. Info Methods and functions tend to be used interchangably, however methods have a deeper meaning than functions. Functions are used to carry out a process that changes input into output. Whether these functions are useful in a certain context is dependent on when and/or where they are used. Within the OOP context, these functions are sometimes called methods (sometimes called operations). You can view methods as like a way how objects do things. For example, the method a person speaks involves opening their mouth and letting out their voice. In this case, unlike functions, methods are meant to have meaningful purposes. Activity: Decomposing a Complex Program into Methods Recall the simple calculator application you created in Practical 03 Task 6. The prepared solution can be split into several methods carrying out different purposes. Obtaining the option to choose the type of arithmetic operation to be carried out Obtaining user input of two integer values Displaying results from user inputs Consider each of the following methods and determine what return type best fits the solution at hand. Method 1: Choosing Arithmetic Operation The discussed solution involved obtaining an option with the use of a while loop like as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Scanner input = new Scanner ( System . in ); int option = 0 ; do { if ( option == 0 ) { System . out . println ( \"1.\\tAddition\" ); System . out . println ( \"2.\\tSubtraction\" ); System . out . println ( \"3.\\tMultiplication\" ); System . out . println ( \"4.\\tDivision\" ); System . out . println ( \"5.\\tModulo (Remainder)\" ); } System . out . print ( \"Enter operation >> \" ); option = input . nextInt (); if ( option < 0 || option > 5 ) System . out . println ( \"Invalid option, try again!\\n\" ); } while ( option < 0 || option > 5 ); Let's encapsulate this part of the solution into a method called selectOperation . The end result is the integer variable option . Therefore, we use the int return type for the method. At the end of this method, we ought to put in a return statement to return option back to the method that called it in the first place. In this case, it would be the main method. selectOperation() should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private static int selectOperation () { // this is going to cause a problem we'll solve later Scanner input = new Scanner ( System . in ); int option = 0 ; do { if ( option == 0 ) { System . out . println ( \"1.\\tAddition\" ); System . out . println ( \"2.\\tSubtraction\" ); System . out . println ( \"3.\\tMultiplication\" ); System . out . println ( \"4.\\tDivision\" ); System . out . println ( \"5.\\tModulo (Remainder)\" ); } System . out . print ( \"Enter operation >> \" ); option = input . nextInt (); if ( option < 0 || option > 5 ) System . out . println ( \"Invalid option, try again!\\n\" ); } while ( option < 0 || option > 5 ); return option ; } Notice that we also added the private and static keywords in front of the method declaration. The use of the private keyword makes a method or variable such that it's only accessible within the class itself. As for the static keyword, for the time being just know that you'll need to use static whenever you're linking methods in a class where a main method is involved. In the main method, enter this in place of the code you just moved into the newly created method. This will retrieve the returned value from the selectOperation() method and keep it in a local variable called option . 1 2 3 4 5 public static void main ( String [] args ) { int option = selectOperation (); /* ... */ } Method 2: User Input of 2 Integer Values This method should retrieve 2 values as according to the code snippet below: 1 2 3 4 5 System . out . println ( \"Enter integer #1 >> \" ); int num1 = input . nextInt (); System . out . println ( \"Enter integer #2 >> \" ); int num2 = input . nextInt (); Let's name the method containing this code snippet getUserInput() . Apart from using primitive data types, one can also return arrays of such data types from a method. We can combine these two numbers into an integer array like as follows: 1 2 3 4 5 6 7 8 9 10 11 12 private static int [] getUserInput () { System . out . println ( \"Enter integer #1 >> \" ); int num1 = input . nextInt (); System . out . println ( \"Enter integer #2 >> \" ); int num2 = input . nextInt (); // create an integer array to contain both user inputs int results [] = { num1 , num2 }; return results ; } Here, we are assuming that the first value entered corresponds to results[0] and the second value corresponds to results[1] . Like the previous method, let's call the getUserInput() method from the main method and save the array in a local array variable in the main method. 1 2 3 4 5 6 7 public static void main ( String [] args ) { int option = selectOperation (); int [] userInput = getUserInput (); /* ... */ } However, note that we do not have a Scanner object (let alone one called input ) in this method. That Scanner object now belongs to the selectOperation() method. If you run the program now, it will throw an exception stating something along the lines of input being non-existent within this newly created method. In order to fix this, we will make the Scanner object global within the class. Remove the Scanner object declaration from selectOperation() and redeclare it as follows at the beginning right after the class declaration: MethodExample.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class MethodExample { private static Scanner input = new Scanner ( System . in ); private static int selectOperation () { /* ... */ } private static int [] getUserInput () { /* ... */ } public static void main ( String [] args ) { int operation = selectOperation (); int [] userInput = getUserInput (); /* ... */ } } Method 3: Displaying Results Now all that's left is to print out the results from the switch statement. The code snippet from the discussed solution is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 switch ( option ) { case 1 : System . out . println ( num1 + \" + \" + num2 + \" = \" + ( num1 + num2 )); break ; case 2 : System . out . println ( num1 + \" - \" + num2 + \" = \" + ( num1 - num2 )); break ; case 3 : System . out . println ( num1 + \" * \" + num2 + \" = \" + ( num1 * num2 )); break ; case 4 : System . out . println ( num1 + \" / \" + num2 + \" = \" + ( num1 / num2 )); break ; case 5 : System . out . println ( num1 + \" mod \" + num2 + \" = \" + ( num1 % num2 )); break ; default : } Here, we are only printing statements; printing statements do not constitute as returning anything to the method that called it in the first place. Since we are not expecting to returning any value at all, this new method we call printResults() will have a void return type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static void printResults ( int option , int num1 , int num2 ) { switch ( option ) { case 1 : System . out . println ( num1 + \" + \" + num2 + \" = \" + ( num1 + num2 )); break ; case 2 : System . out . println ( num1 + \" - \" + num2 + \" = \" + ( num1 - num2 )); break ; case 3 : System . out . println ( num1 + \" * \" + num2 + \" = \" + ( num1 * num2 )); break ; case 4 : System . out . println ( num1 + \" / \" + num2 + \" = \" + ( num1 / num2 )); break ; case 5 : System . out . println ( num1 + \" mod \" + num2 + \" = \" + ( num1 % num2 )); break ; default : } } Note here that this time, we are passing parameters into this method. This is because unlike the last 2 methods which did not require any input from the method that called it, this method requires those 3 variables in order to function. This method is assuming that the first value is to be regarded as the operator option selected, followed by the first and second input numbers from the user respectively. There is no set rule as to when and where a method should require parameters. Whether or not a method should require parameter(s), in the declaration, how many of them are required, and/or consequently return value(s) is dependent on how you design your solution. In this case, since printResults() does not return any value to the method that called it, we do not need to store anything into a local variable. In the main method, invoke this method as is without equating it to a local variable like as follows. However, since it requires 3 parameters for it to work, when invoking the method you will need to enter the required values (being option and userInput ). 1 2 3 4 5 6 7 public static void main ( String [] args ) { int option = selectOperation (); int [] userInput = getUserInput (); printResults ( option , userInput [ 0 ] , userInput [ 1 ] ); } Putting them altogether And voila, you now have a solution that's more modular by splitting a working solution into 3 different methods that work separately from each other. The main method is now relegated to only invoking methods as and when they are needed. Tasks Task 1 Write a method that computes the multiplication of the digits in an integer. Use the following method header: public static int mulDigit ( int n ) For exmaple, mulDigit(234) returns 24 (i.e., 2 \u00d7 3 \u00d7 4). Hint Use the % operator to extract digits, and the / operator to remove the extracted digit. For instance, to extract 4 from 234, use 234 % 10 (= 4). To remove 4 from 234, use 234 / 10 (= 23). Use a loop to repeatedly extract and remove the digit until all the digits are extracted. Write a test program that prompts the user to enter an integer and displays the multiplication of all its digits. Write a test program that prompts the user to enter an integer, then displays the result of all its digits multiplied together randomly generates a number ranging between (and inclusive of) 100 and 10,000, then displays the result of all its digits multiplied together Task 2 Create a class called PrimeNumber which contains 3 methods: isPrimeNumber(int num) This will return true if num is prime, and false otherwise. getListOfPrimeNumbers(int start, int end) This will return the list of prime numbers between the start and end number. getDivisible(int num) This will return the list of divisible numbers for the provided number. Task 3 Write a method that converts a hexadecimal number into a decimal number. For example, ABCD 16 = A \u00d7 16 3 + B \u00d7 16 2 + C \u00d7 16 1 + D \u00d7 16 0 = 43981 You may use the following reference: Hexadecimal 0 1 2 3 4 5 6 7 8 9 A B C D E F Decimal 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Once you have completed your method, you can verify your result by calling the following function: Integer . parseInt ( < number_input > , 16 ); Test your program with the following values: 2AC, AB3F, FF99 Task 4 Write a class that contains the following two methods: /* Convert miles to kilometers */ public static double mileToKilometer ( double mile ) /* Convert kilometers to miles */ public static double kilometerToMile ( double kilometer ) The formula for the conversion is: 1 mile = 1.609 kilometers Write a test program that invokes these methods when necessary after prompting to enter either a value in kilometers or miles (ask for choice first). Task 5 Write a class that contains the following two methods: /* Convert pounds to kilograms */ public static double poundToKilogram ( double pound ) /* Convert kilograms to pounds */ public static double kilogramToPound ( double kilogram ) The formula for the conversion is: pound = 0.453 \u00d7 kilograms kilogram = 2.204 \u00d7 pound Write a test program that invokes these methods when necessary after prompting to enter either a value in kilograms or pounds (ask for choice first). Task 6 Utilize methods to solve this multidimensional array problem. Write a program that randomly fills in 0s and 1s into a Tic-tac-toe board, prints the board, and find the rows, columns, or diagonals with all 0s or 1s. Use a two-dimensional array to represent a Tic-tac-toe board. Hint Use Math.random() * 2 to randomly generate the 0s and 1s. Here are some sample runs of the program: TicTacToe board: 0 1 0 1 1 1 1 1 0 Result(s): All 1's on row 1 All 1's on column 1 TicTacToe board: 0 1 1 0 0 0 0 0 1 Result(s): All 0's on row 1 All 0's on column 0 TicTacToe board: 0 1 0 1 0 1 0 0 1 Result(s): All 0's on subdiagonal TicTacToe board: 1 1 1 0 1 0 1 1 1 Result(s): All 1's on row 0 All 1's on row 2 All 1's on column 1 All 1's on major diagonal All 1's on subdiagonal","title":"Practical 05: Methods"},{"location":"archive/202108/lab05/#practical-05-methods","text":"Aside from being able to modularize code, using methods is integral to when we start covering Classes and Objects in the next session. Info Methods and functions tend to be used interchangably, however methods have a deeper meaning than functions. Functions are used to carry out a process that changes input into output. Whether these functions are useful in a certain context is dependent on when and/or where they are used. Within the OOP context, these functions are sometimes called methods (sometimes called operations). You can view methods as like a way how objects do things. For example, the method a person speaks involves opening their mouth and letting out their voice. In this case, unlike functions, methods are meant to have meaningful purposes.","title":"Practical 05: Methods"},{"location":"archive/202108/lab05/#activity-decomposing-a-complex-program-into-methods","text":"Recall the simple calculator application you created in Practical 03 Task 6. The prepared solution can be split into several methods carrying out different purposes. Obtaining the option to choose the type of arithmetic operation to be carried out Obtaining user input of two integer values Displaying results from user inputs Consider each of the following methods and determine what return type best fits the solution at hand.","title":"Activity: Decomposing a Complex Program into Methods"},{"location":"archive/202108/lab05/#method-1-choosing-arithmetic-operation","text":"The discussed solution involved obtaining an option with the use of a while loop like as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Scanner input = new Scanner ( System . in ); int option = 0 ; do { if ( option == 0 ) { System . out . println ( \"1.\\tAddition\" ); System . out . println ( \"2.\\tSubtraction\" ); System . out . println ( \"3.\\tMultiplication\" ); System . out . println ( \"4.\\tDivision\" ); System . out . println ( \"5.\\tModulo (Remainder)\" ); } System . out . print ( \"Enter operation >> \" ); option = input . nextInt (); if ( option < 0 || option > 5 ) System . out . println ( \"Invalid option, try again!\\n\" ); } while ( option < 0 || option > 5 ); Let's encapsulate this part of the solution into a method called selectOperation . The end result is the integer variable option . Therefore, we use the int return type for the method. At the end of this method, we ought to put in a return statement to return option back to the method that called it in the first place. In this case, it would be the main method. selectOperation() should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private static int selectOperation () { // this is going to cause a problem we'll solve later Scanner input = new Scanner ( System . in ); int option = 0 ; do { if ( option == 0 ) { System . out . println ( \"1.\\tAddition\" ); System . out . println ( \"2.\\tSubtraction\" ); System . out . println ( \"3.\\tMultiplication\" ); System . out . println ( \"4.\\tDivision\" ); System . out . println ( \"5.\\tModulo (Remainder)\" ); } System . out . print ( \"Enter operation >> \" ); option = input . nextInt (); if ( option < 0 || option > 5 ) System . out . println ( \"Invalid option, try again!\\n\" ); } while ( option < 0 || option > 5 ); return option ; } Notice that we also added the private and static keywords in front of the method declaration. The use of the private keyword makes a method or variable such that it's only accessible within the class itself. As for the static keyword, for the time being just know that you'll need to use static whenever you're linking methods in a class where a main method is involved. In the main method, enter this in place of the code you just moved into the newly created method. This will retrieve the returned value from the selectOperation() method and keep it in a local variable called option . 1 2 3 4 5 public static void main ( String [] args ) { int option = selectOperation (); /* ... */ }","title":"Method 1: Choosing Arithmetic Operation"},{"location":"archive/202108/lab05/#method-2-user-input-of-2-integer-values","text":"This method should retrieve 2 values as according to the code snippet below: 1 2 3 4 5 System . out . println ( \"Enter integer #1 >> \" ); int num1 = input . nextInt (); System . out . println ( \"Enter integer #2 >> \" ); int num2 = input . nextInt (); Let's name the method containing this code snippet getUserInput() . Apart from using primitive data types, one can also return arrays of such data types from a method. We can combine these two numbers into an integer array like as follows: 1 2 3 4 5 6 7 8 9 10 11 12 private static int [] getUserInput () { System . out . println ( \"Enter integer #1 >> \" ); int num1 = input . nextInt (); System . out . println ( \"Enter integer #2 >> \" ); int num2 = input . nextInt (); // create an integer array to contain both user inputs int results [] = { num1 , num2 }; return results ; } Here, we are assuming that the first value entered corresponds to results[0] and the second value corresponds to results[1] . Like the previous method, let's call the getUserInput() method from the main method and save the array in a local array variable in the main method. 1 2 3 4 5 6 7 public static void main ( String [] args ) { int option = selectOperation (); int [] userInput = getUserInput (); /* ... */ } However, note that we do not have a Scanner object (let alone one called input ) in this method. That Scanner object now belongs to the selectOperation() method. If you run the program now, it will throw an exception stating something along the lines of input being non-existent within this newly created method. In order to fix this, we will make the Scanner object global within the class. Remove the Scanner object declaration from selectOperation() and redeclare it as follows at the beginning right after the class declaration: MethodExample.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class MethodExample { private static Scanner input = new Scanner ( System . in ); private static int selectOperation () { /* ... */ } private static int [] getUserInput () { /* ... */ } public static void main ( String [] args ) { int operation = selectOperation (); int [] userInput = getUserInput (); /* ... */ } }","title":"Method 2: User Input of 2 Integer Values"},{"location":"archive/202108/lab05/#method-3-displaying-results","text":"Now all that's left is to print out the results from the switch statement. The code snippet from the discussed solution is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 switch ( option ) { case 1 : System . out . println ( num1 + \" + \" + num2 + \" = \" + ( num1 + num2 )); break ; case 2 : System . out . println ( num1 + \" - \" + num2 + \" = \" + ( num1 - num2 )); break ; case 3 : System . out . println ( num1 + \" * \" + num2 + \" = \" + ( num1 * num2 )); break ; case 4 : System . out . println ( num1 + \" / \" + num2 + \" = \" + ( num1 / num2 )); break ; case 5 : System . out . println ( num1 + \" mod \" + num2 + \" = \" + ( num1 % num2 )); break ; default : } Here, we are only printing statements; printing statements do not constitute as returning anything to the method that called it in the first place. Since we are not expecting to returning any value at all, this new method we call printResults() will have a void return type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static void printResults ( int option , int num1 , int num2 ) { switch ( option ) { case 1 : System . out . println ( num1 + \" + \" + num2 + \" = \" + ( num1 + num2 )); break ; case 2 : System . out . println ( num1 + \" - \" + num2 + \" = \" + ( num1 - num2 )); break ; case 3 : System . out . println ( num1 + \" * \" + num2 + \" = \" + ( num1 * num2 )); break ; case 4 : System . out . println ( num1 + \" / \" + num2 + \" = \" + ( num1 / num2 )); break ; case 5 : System . out . println ( num1 + \" mod \" + num2 + \" = \" + ( num1 % num2 )); break ; default : } } Note here that this time, we are passing parameters into this method. This is because unlike the last 2 methods which did not require any input from the method that called it, this method requires those 3 variables in order to function. This method is assuming that the first value is to be regarded as the operator option selected, followed by the first and second input numbers from the user respectively. There is no set rule as to when and where a method should require parameters. Whether or not a method should require parameter(s), in the declaration, how many of them are required, and/or consequently return value(s) is dependent on how you design your solution. In this case, since printResults() does not return any value to the method that called it, we do not need to store anything into a local variable. In the main method, invoke this method as is without equating it to a local variable like as follows. However, since it requires 3 parameters for it to work, when invoking the method you will need to enter the required values (being option and userInput ). 1 2 3 4 5 6 7 public static void main ( String [] args ) { int option = selectOperation (); int [] userInput = getUserInput (); printResults ( option , userInput [ 0 ] , userInput [ 1 ] ); }","title":"Method 3: Displaying Results"},{"location":"archive/202108/lab05/#putting-them-altogether","text":"And voila, you now have a solution that's more modular by splitting a working solution into 3 different methods that work separately from each other. The main method is now relegated to only invoking methods as and when they are needed.","title":"Putting them altogether"},{"location":"archive/202108/lab05/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab05/#task-1","text":"Write a method that computes the multiplication of the digits in an integer. Use the following method header: public static int mulDigit ( int n ) For exmaple, mulDigit(234) returns 24 (i.e., 2 \u00d7 3 \u00d7 4). Hint Use the % operator to extract digits, and the / operator to remove the extracted digit. For instance, to extract 4 from 234, use 234 % 10 (= 4). To remove 4 from 234, use 234 / 10 (= 23). Use a loop to repeatedly extract and remove the digit until all the digits are extracted. Write a test program that prompts the user to enter an integer and displays the multiplication of all its digits. Write a test program that prompts the user to enter an integer, then displays the result of all its digits multiplied together randomly generates a number ranging between (and inclusive of) 100 and 10,000, then displays the result of all its digits multiplied together","title":"Task 1"},{"location":"archive/202108/lab05/#task-2","text":"Create a class called PrimeNumber which contains 3 methods: isPrimeNumber(int num) This will return true if num is prime, and false otherwise. getListOfPrimeNumbers(int start, int end) This will return the list of prime numbers between the start and end number. getDivisible(int num) This will return the list of divisible numbers for the provided number.","title":"Task 2"},{"location":"archive/202108/lab05/#task-3","text":"Write a method that converts a hexadecimal number into a decimal number. For example, ABCD 16 = A \u00d7 16 3 + B \u00d7 16 2 + C \u00d7 16 1 + D \u00d7 16 0 = 43981 You may use the following reference: Hexadecimal 0 1 2 3 4 5 6 7 8 9 A B C D E F Decimal 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Once you have completed your method, you can verify your result by calling the following function: Integer . parseInt ( < number_input > , 16 ); Test your program with the following values: 2AC, AB3F, FF99","title":"Task 3"},{"location":"archive/202108/lab05/#task-4","text":"Write a class that contains the following two methods: /* Convert miles to kilometers */ public static double mileToKilometer ( double mile ) /* Convert kilometers to miles */ public static double kilometerToMile ( double kilometer ) The formula for the conversion is: 1 mile = 1.609 kilometers Write a test program that invokes these methods when necessary after prompting to enter either a value in kilometers or miles (ask for choice first).","title":"Task 4"},{"location":"archive/202108/lab05/#task-5","text":"Write a class that contains the following two methods: /* Convert pounds to kilograms */ public static double poundToKilogram ( double pound ) /* Convert kilograms to pounds */ public static double kilogramToPound ( double kilogram ) The formula for the conversion is: pound = 0.453 \u00d7 kilograms kilogram = 2.204 \u00d7 pound Write a test program that invokes these methods when necessary after prompting to enter either a value in kilograms or pounds (ask for choice first).","title":"Task 5"},{"location":"archive/202108/lab05/#task-6","text":"Utilize methods to solve this multidimensional array problem. Write a program that randomly fills in 0s and 1s into a Tic-tac-toe board, prints the board, and find the rows, columns, or diagonals with all 0s or 1s. Use a two-dimensional array to represent a Tic-tac-toe board. Hint Use Math.random() * 2 to randomly generate the 0s and 1s. Here are some sample runs of the program: TicTacToe board: 0 1 0 1 1 1 1 1 0 Result(s): All 1's on row 1 All 1's on column 1 TicTacToe board: 0 1 1 0 0 0 0 0 1 Result(s): All 0's on row 1 All 0's on column 0 TicTacToe board: 0 1 0 1 0 1 0 0 1 Result(s): All 0's on subdiagonal TicTacToe board: 1 1 1 0 1 0 1 1 1 Result(s): All 1's on row 0 All 1's on row 2 All 1's on column 1 All 1's on major diagonal All 1's on subdiagonal","title":"Task 6"},{"location":"archive/202108/lab06/","text":"Practical 06: Classes and Objects We will now begin to implement classes and declare them as objects in this practical session. In procedural programming, the idea is to break down problems into required actions to be taken. Here, one may associate solutions as verbs (i.e., to-do actions). Previously, we only dabbled in one class file per task solution. In those classes, we still approached our solutions in a procedural programming manner. However, in object-oriented programming, one has to decompose problems into objects (i.e., nouns). One must consider what objects are needed in order for the program to function. These objects will contain attributes and methods (i.e., their own functions) to play roles in a program. Tasks Task 1 Create a class named Household (save as Household.java ) that includes a default constructor and two data fields (number of occupants and annual income). And then, create a driver program (save as TestHousehold.java ) to test the class. Sample output for the driver program: Household 1 *********** Number of occupants: 0 Annual Income: .00 Values have been modified Number of occupants: 6 Annual Income: 25,000.00 Modify the default constructor for the Household class to set the occupants field to 1 and annual income field to 0. Then, run the driver program again. Create an additional overloaded constructor for the Household class. This constructor receives an integer argument and assigns the value to the occupant field. Change any needed statements to the driver program to ensure that the overloaded constructor works correctly. Save and test the changes made. Create a third overloaded constructor for the Household class. This constructor receives two arguments, the values of which are assigned to the occupant and income fields respectively. Add any needed statements to the driver program to ensure that the overloaded constructor works correctly. Save and test the changes made. Create a method named calcAverageIncome() (add it to the Household class) to calculate the average income for each household. The formula is as follows: Average income = annual income / number of occupants Add any needed statements to the driver program to ensure that the method works correctly. Save and test the changes made. Task 2 Define a class named Planet , which contains two instance variables that store the name of the planet ( name ) and the number of days the planet takes to travel around the Sun ( travelDays ). Write a method printPlanet() which displays the planet's details. In addition, write a test class to test your Planet class. Sample output for the driver program: Enter the planet name: Earth Enter the travel days: 365 ----------------------------- Planet Name: Earth Travel Days: 365 Add a calculateAge() method to your Planet class which calculates the person's age on that planet. Use the following formula: Age on the planet = (age * 365) / travelDays The calculateAverage() method should receive an argument that represents the age on Earth. Modify your test class to obtain user input on their age on Earth and test your calculateAge() method. Planet Travel Days Venus 255 Mercury 88 Jupiter 4380 Saturn 10767 Sample output for driver program: Enter your age on Earth: 20 Enter the planet name: Venus Enter the travel days for Venus: 255 ------------------------------------- Planet Name: Venus Travel Days: 255 Age on Venus: 28 Add the following constructors to your Planet class: A no-arg constructor to initialize the value of name to \"Earth\" and travelDays to 365. A constructor with two parameters. Modify your test class to test the constructors you have defined. Task 3 Create a class based on the following class diagram: Note: Initialize the value of type to \u201cApartment\u201d, zone to \u2018A\u2019, price to 68000.00, numberOfBedrooms to 3 and freehold to false for no-arg constructor. Use the toString() method to print out all house details. Create a driver program for the class you just created to test all the available constructors and methods. Create three house objects. Create an array to store the three house objects. Modify the House class by using the this keyword to refer to the data member(s) and constructor (if possible).","title":"Practical 06: Classes and Objects"},{"location":"archive/202108/lab06/#practical-06-classes-and-objects","text":"We will now begin to implement classes and declare them as objects in this practical session. In procedural programming, the idea is to break down problems into required actions to be taken. Here, one may associate solutions as verbs (i.e., to-do actions). Previously, we only dabbled in one class file per task solution. In those classes, we still approached our solutions in a procedural programming manner. However, in object-oriented programming, one has to decompose problems into objects (i.e., nouns). One must consider what objects are needed in order for the program to function. These objects will contain attributes and methods (i.e., their own functions) to play roles in a program.","title":"Practical 06: Classes and Objects"},{"location":"archive/202108/lab06/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab06/#task-1","text":"Create a class named Household (save as Household.java ) that includes a default constructor and two data fields (number of occupants and annual income). And then, create a driver program (save as TestHousehold.java ) to test the class. Sample output for the driver program: Household 1 *********** Number of occupants: 0 Annual Income: .00 Values have been modified Number of occupants: 6 Annual Income: 25,000.00 Modify the default constructor for the Household class to set the occupants field to 1 and annual income field to 0. Then, run the driver program again. Create an additional overloaded constructor for the Household class. This constructor receives an integer argument and assigns the value to the occupant field. Change any needed statements to the driver program to ensure that the overloaded constructor works correctly. Save and test the changes made. Create a third overloaded constructor for the Household class. This constructor receives two arguments, the values of which are assigned to the occupant and income fields respectively. Add any needed statements to the driver program to ensure that the overloaded constructor works correctly. Save and test the changes made. Create a method named calcAverageIncome() (add it to the Household class) to calculate the average income for each household. The formula is as follows: Average income = annual income / number of occupants Add any needed statements to the driver program to ensure that the method works correctly. Save and test the changes made.","title":"Task 1"},{"location":"archive/202108/lab06/#task-2","text":"Define a class named Planet , which contains two instance variables that store the name of the planet ( name ) and the number of days the planet takes to travel around the Sun ( travelDays ). Write a method printPlanet() which displays the planet's details. In addition, write a test class to test your Planet class. Sample output for the driver program: Enter the planet name: Earth Enter the travel days: 365 ----------------------------- Planet Name: Earth Travel Days: 365 Add a calculateAge() method to your Planet class which calculates the person's age on that planet. Use the following formula: Age on the planet = (age * 365) / travelDays The calculateAverage() method should receive an argument that represents the age on Earth. Modify your test class to obtain user input on their age on Earth and test your calculateAge() method. Planet Travel Days Venus 255 Mercury 88 Jupiter 4380 Saturn 10767 Sample output for driver program: Enter your age on Earth: 20 Enter the planet name: Venus Enter the travel days for Venus: 255 ------------------------------------- Planet Name: Venus Travel Days: 255 Age on Venus: 28 Add the following constructors to your Planet class: A no-arg constructor to initialize the value of name to \"Earth\" and travelDays to 365. A constructor with two parameters. Modify your test class to test the constructors you have defined.","title":"Task 2"},{"location":"archive/202108/lab06/#task-3","text":"Create a class based on the following class diagram: Note: Initialize the value of type to \u201cApartment\u201d, zone to \u2018A\u2019, price to 68000.00, numberOfBedrooms to 3 and freehold to false for no-arg constructor. Use the toString() method to print out all house details. Create a driver program for the class you just created to test all the available constructors and methods. Create three house objects. Create an array to store the three house objects. Modify the House class by using the this keyword to refer to the data member(s) and constructor (if possible).","title":"Task 3"},{"location":"archive/202108/lab07/","text":"Practical 07: Inheritance Inheritance is one of the key concepts in object-oriented programming. With it, one can group similar elements (i.e., attributes and/or methods) of a group of classes and stash them in a superclass/parent class. The separate classes (now subclasses/child classes) will inherit these similar elements while having their own unique elements that make them different from the other fellow subclasses. Activity: Implementing \"IS-A\" Relationships Inheritance defines relationships between classes, the \"IS-A\" relationship type in particular. Illustration Example To illustrate this, let's compare two different groups of academic staff in Taylor's College, namely the full-time staff and part-time staff. Here, we are implying the following: A full-time academic staff member \" IS-A \" academic staff. A part-time academic staff member \" IS-A \" academic staff. Ignore the grammatical error, the idea's to show relations between these superclass and subclasses. \ud83d\ude1d On a base level, every academic staff has common attributes including: full name ( fullName ) staff ID ( id ) qualification level (assume 1 stands for Bachelor, 2 stands for Masters, and 3 stands for PhD) ( qualificationLevel ) Now let's compare some differences between the two types of staff: Full time academic staff can have two types of rankings: Lecturer, Senior Lecturer, Head of Department. Let's assume 1 stands for the Lecturer rank, and 2 stands for Senior Lecturer, and 3 stands for Head of Department. We will call this value rank . Part-time academic staff do not have a ranking to climb. Full-time academic staff are required to contribute hours either into the research field or undergo trainings. For now, let's assume the hours spent on these duties stack together with each other. We will call this value contributionHours . Let's also assume that part-time academic staff, on the other hand, are not expected to offer such contributions to the College. Part-time staff work on an hourly wage rate ( hourlyRate ). The salary amount paid to part-time staff is dependent on the product of their hourly wage rate and the number of hours worked. Full-time staff, on the other hand, are paid a baseline salary amount ( baseSalary ), plus any bonus received. Implementing the Idea AcademicStaff.java We begin by implementing the superclass first; name it AcademicStaff . Let's assume that the AcademicStaff class also has 3 methods: toString() , printStaff() and calculateSalary() . For now, we will say that calculateSalary() will immediately return 0 from a generic AcademicStaff object. We will also implement toString() as a method that returns a String - the reason for this will be explained when we touch on Polymorphism next week. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor public AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } // Accessor and Mutator Methods public String getFullName () { return fullName ; } public String getId () { return id ; } public int getQualificationLevel () { return qualificationLevel ; } public void setFullName ( String fullName ) { this . fullName = fullName ; } public void setId ( String id ) { this . id = id ; } public void setQualificationLevel ( int qualificationLevel ) { this . qualificationLevel = qualificationLevel ; } public String toString () { String qualification = \"\" ; switch ( qualificationLevel ) { case 1 : qualification = \"Bachelor\" ; break ; case 2 : qualification = \"Master\" ; break ; case 3 : qualification = \"Doctorate\" ; break ; default : } return \"Full Name: \" + fullName + \"\\nStaff ID: \" + id + \"\\nQualification Type: \" + qualification ; } public void printStaff () { System . out . println ( this . toString ()); } public double calculateSalary () { return 0 ; } } We will now implement the subclasses next. FullTimeStaff.java We've already established the fact that full-time staff's salary is equal to the base salary + bonus for the month. Let's assume that the FullTimeStaff class has a specific method that is used during the calculation of the salary such that the bonus depends on the amount of contribution hours put in. Specifically, assume Bonus Received = $ (Number of contribution hours \u00d7 100) We will call this method getBonus() . FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructor public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } // Accessor and Mutator Methods public int getRank () { return rank ; } public int getContributionHours () { return contributionHours ; } public double getBaseSalary () { return baseSalary ; } public void setRank ( int rank ) { this . rank = rank ; } public void setContributionHours ( int contributionHours ) { this . contributionHours = contributionHours ; } public void setBaseSalary ( double baseSalary ) { this . baseSalary = baseSalary ; } // Determines bonus amount public double getBonus () { return contributionHours * 100 ; } } Recall that in order for a subclass to be able to call a method or constructor belonging to the superclass, you will need to use the super keyword. PartTimeStaff.java There are also some specifics for the part-time staff. Let's assume that one may add hours the number of hours worked in addition to the number of hours already being worked on. We'll name this method addHoursWorked() , which takes in one parameter value called additionalHours . PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructor public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } // Accessor and Mutator Methods public double getHourlyRate () { return hourlyRate ; } public int getHoursWorked () { return hoursWorked ; } public void setHourlyRate ( double hourlyRate ) { this . hourlyRate = hourlyRate ; } public void setHoursWorked ( int hoursWorked ) { this . hoursWorked = hoursWorked ; } // Add hours worked public void addHoursWorked ( int additionalHours ) { this . hoursWorked += additionalHours ; } } Driver Program Let's create a separate class acting as the driver class which will contain the main method. We can create objects of each subclass like as follows: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Driver { public static void main ( String [] args ) { FullTimeStaff staff1 = new FullTimeStaff ( \"Horace Diaz\" , \"ABC123\" , 3 , 3 , 10 , 3000 ); System . out . println ( staff1 . toString ()); System . out . println ( \"\\n\" ); PartTimeStaff staff2 = new PartTimeStaff ( \"Ivan Lam\" , \"XYZ787\" , 2 , 125 , 20 ); System . out . println ( staff2 . toString ()); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); staff2 . addHoursWorked ( 5 ); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); } } At the end of this activity, you should be able to implement inheritance in your program. However, we are not done with this program just yet. There are still the calculation of salary still displaying 0 if the respective method is called, and each of the subclass' toString() methods does not show any difference. Output: Full Name: Horace Diaz Staff ID: ABC123 Qualification Type: Doctorate Full Name: Ivan Lam Staff ID: XYZ787 Qualification Type: Master (Staff2) Hours worked: 20 (Staff2) Hours worked: 25 We will get into those during the next practical.","title":"Practical 07: Inheritance"},{"location":"archive/202108/lab07/#practical-07-inheritance","text":"Inheritance is one of the key concepts in object-oriented programming. With it, one can group similar elements (i.e., attributes and/or methods) of a group of classes and stash them in a superclass/parent class. The separate classes (now subclasses/child classes) will inherit these similar elements while having their own unique elements that make them different from the other fellow subclasses.","title":"Practical 07: Inheritance"},{"location":"archive/202108/lab07/#activity-implementing-is-a-relationships","text":"Inheritance defines relationships between classes, the \"IS-A\" relationship type in particular.","title":"Activity: Implementing \"IS-A\" Relationships"},{"location":"archive/202108/lab07/#illustration-example","text":"To illustrate this, let's compare two different groups of academic staff in Taylor's College, namely the full-time staff and part-time staff. Here, we are implying the following: A full-time academic staff member \" IS-A \" academic staff. A part-time academic staff member \" IS-A \" academic staff. Ignore the grammatical error, the idea's to show relations between these superclass and subclasses. \ud83d\ude1d On a base level, every academic staff has common attributes including: full name ( fullName ) staff ID ( id ) qualification level (assume 1 stands for Bachelor, 2 stands for Masters, and 3 stands for PhD) ( qualificationLevel ) Now let's compare some differences between the two types of staff: Full time academic staff can have two types of rankings: Lecturer, Senior Lecturer, Head of Department. Let's assume 1 stands for the Lecturer rank, and 2 stands for Senior Lecturer, and 3 stands for Head of Department. We will call this value rank . Part-time academic staff do not have a ranking to climb. Full-time academic staff are required to contribute hours either into the research field or undergo trainings. For now, let's assume the hours spent on these duties stack together with each other. We will call this value contributionHours . Let's also assume that part-time academic staff, on the other hand, are not expected to offer such contributions to the College. Part-time staff work on an hourly wage rate ( hourlyRate ). The salary amount paid to part-time staff is dependent on the product of their hourly wage rate and the number of hours worked. Full-time staff, on the other hand, are paid a baseline salary amount ( baseSalary ), plus any bonus received.","title":"Illustration Example"},{"location":"archive/202108/lab07/#implementing-the-idea","text":"","title":"Implementing the Idea"},{"location":"archive/202108/lab07/#academicstaffjava","text":"We begin by implementing the superclass first; name it AcademicStaff . Let's assume that the AcademicStaff class also has 3 methods: toString() , printStaff() and calculateSalary() . For now, we will say that calculateSalary() will immediately return 0 from a generic AcademicStaff object. We will also implement toString() as a method that returns a String - the reason for this will be explained when we touch on Polymorphism next week. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor public AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } // Accessor and Mutator Methods public String getFullName () { return fullName ; } public String getId () { return id ; } public int getQualificationLevel () { return qualificationLevel ; } public void setFullName ( String fullName ) { this . fullName = fullName ; } public void setId ( String id ) { this . id = id ; } public void setQualificationLevel ( int qualificationLevel ) { this . qualificationLevel = qualificationLevel ; } public String toString () { String qualification = \"\" ; switch ( qualificationLevel ) { case 1 : qualification = \"Bachelor\" ; break ; case 2 : qualification = \"Master\" ; break ; case 3 : qualification = \"Doctorate\" ; break ; default : } return \"Full Name: \" + fullName + \"\\nStaff ID: \" + id + \"\\nQualification Type: \" + qualification ; } public void printStaff () { System . out . println ( this . toString ()); } public double calculateSalary () { return 0 ; } } We will now implement the subclasses next.","title":"AcademicStaff.java"},{"location":"archive/202108/lab07/#fulltimestaffjava","text":"We've already established the fact that full-time staff's salary is equal to the base salary + bonus for the month. Let's assume that the FullTimeStaff class has a specific method that is used during the calculation of the salary such that the bonus depends on the amount of contribution hours put in. Specifically, assume Bonus Received = $ (Number of contribution hours \u00d7 100) We will call this method getBonus() . FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructor public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } // Accessor and Mutator Methods public int getRank () { return rank ; } public int getContributionHours () { return contributionHours ; } public double getBaseSalary () { return baseSalary ; } public void setRank ( int rank ) { this . rank = rank ; } public void setContributionHours ( int contributionHours ) { this . contributionHours = contributionHours ; } public void setBaseSalary ( double baseSalary ) { this . baseSalary = baseSalary ; } // Determines bonus amount public double getBonus () { return contributionHours * 100 ; } } Recall that in order for a subclass to be able to call a method or constructor belonging to the superclass, you will need to use the super keyword.","title":"FullTimeStaff.java"},{"location":"archive/202108/lab07/#parttimestaffjava","text":"There are also some specifics for the part-time staff. Let's assume that one may add hours the number of hours worked in addition to the number of hours already being worked on. We'll name this method addHoursWorked() , which takes in one parameter value called additionalHours . PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructor public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } // Accessor and Mutator Methods public double getHourlyRate () { return hourlyRate ; } public int getHoursWorked () { return hoursWorked ; } public void setHourlyRate ( double hourlyRate ) { this . hourlyRate = hourlyRate ; } public void setHoursWorked ( int hoursWorked ) { this . hoursWorked = hoursWorked ; } // Add hours worked public void addHoursWorked ( int additionalHours ) { this . hoursWorked += additionalHours ; } }","title":"PartTimeStaff.java"},{"location":"archive/202108/lab07/#driver-program","text":"Let's create a separate class acting as the driver class which will contain the main method. We can create objects of each subclass like as follows: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Driver { public static void main ( String [] args ) { FullTimeStaff staff1 = new FullTimeStaff ( \"Horace Diaz\" , \"ABC123\" , 3 , 3 , 10 , 3000 ); System . out . println ( staff1 . toString ()); System . out . println ( \"\\n\" ); PartTimeStaff staff2 = new PartTimeStaff ( \"Ivan Lam\" , \"XYZ787\" , 2 , 125 , 20 ); System . out . println ( staff2 . toString ()); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); staff2 . addHoursWorked ( 5 ); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); } } At the end of this activity, you should be able to implement inheritance in your program. However, we are not done with this program just yet. There are still the calculation of salary still displaying 0 if the respective method is called, and each of the subclass' toString() methods does not show any difference. Output: Full Name: Horace Diaz Staff ID: ABC123 Qualification Type: Doctorate Full Name: Ivan Lam Staff ID: XYZ787 Qualification Type: Master (Staff2) Hours worked: 20 (Staff2) Hours worked: 25 We will get into those during the next practical.","title":"Driver Program"},{"location":"archive/202108/lab08/","text":"Practical 08: Polymorphism Polymorphism is another key concept in object-oriented programming. It refers to the capability of objects to react differently to the same method. Polymorphism can be implemented in the form of multiple methods having the same name. Java code uses a late-binding technique to support polymorphism; the method to be invoked is decided at runtime. Activity: Overloading Methods vs. Overriding Methods Overloaded methods are methods that have the same name, but different argument lists. Overriding , on the other hand, occurs when a subclass method has the same name, same return type, and same argument list as the superclass method. Overloading Methods One example of overloading methods that we have already covered during lecture when we first began going through classes and objects is through the use of multiple constructors. Going back to the previous activity, let's look at the FullTimeStaff class. Here, let's assume that if baseSalary isn't specified, it will be determined immediately by the rank entered. We'll now create a separate constructor method that takes in the same parameters, except baseSalary is excluded from this list. FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; switch ( this . rank ) { case 1 : this . baseSalary = 2000 ; break ; case 2 : this . baseSalary = 2500 ; break ; case 3 : this . baseSalary = 3000 ; break ; default : this . baseSalary = 0 ; } } /* ... */ } We can do the same with the PartTimeStaff class, but with hoursWorked undefined. In this case, hoursWorked to 0 if unspecified. PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; hoursWorked = 0 ; } /* ... */ } Overloading methods isn't just restricted to constructors; this can be applied from a procedural programming standpoint. Let's assume that this class has two methods that print out the area of a shape given two different sets of parameters. Shape.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Shape { // Get area of quadrilateral public double getArea ( double width , double height ) { return width * height ; } // Get area of circle public double getArea ( double radius ) { return Math . PI * radius * radius ; } /* ... */ } The key idea behind overloading methods is to have methods of the same name, but different argument lists . Here, depending on whether one double value or two double values are entered, you get two different methods of calculating the area of the shape. Overloading methods is also not restricted by the return type being used. For example, one may create a getArea() method that returns an integer value based on yet another argument list. The number of times a method is overloaded is not restricted as well, but ensure not to have ambiguous parameter lists like as follows: Shape.java 1 2 3 4 5 6 7 8 9 10 11 public class Shape { public double getArea ( double width , double height ) { /* ... */ } public double getArea ( double radius , int dimension ) { /* ... */ } /* ... */ } Here, the compiler does not know which method to use when invoked with a parameter list where the second number can be interpreted as either an integer or double. Overriding Methods Overriding methods involve having methods of the same name, return type, and argument list between superclass and subclass. Going back to last week's activity again, we will now override the toString() and calculateSalary() methods of both subclasses. FullTimeStaff.java FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class FullTimeStaff extends AcademicStaff { /* ... */ public double calculateSalary () { return baseSalary + getBonus (); } public String toString () { String rankName = \"\" ; switch ( rank ) { case 1 : rankName = \"Lecturer\" ; break ; case 2 : rankName = \"Senior Lecturer\" ; break ; case 3 : rankName = \"Professor\" ; break ; default : } return super . toString () + \"\\nStaff Rank: \" + rankName ; } } PartTimeStaff.java PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 public class PartTimeStaff extends AcademicStaff { /* ... */ public double calculateSalary () { return hourlyRate * hoursWorked ; } public String toString () { return super . toString () + \"\\nStaff Rank: Part-Time Lecturer\" ; } } In this example, we have already overriden toString() twice, once between the superclass and subclass we have just created, and the other via overriding from the Object class. In Java, all classes are considered subclasses of the Object class, which in turn, is the superclass of just about any class that exists in Java and any class you create. Java's Object class contains the toString() method by default, which prints out the memory address the object is taking up. This is not particularly helpful to us as regular users who pay no regard to where about the object is specifically being stored in the computer's memory. Making the following modifications to the main method in the driver class will render the following output: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Driver { public static void main ( String [] args ) { FullTimeStaff staff1 = new FullTimeStaff ( \"Horace Diaz\" , \"ABC123\" , 3 , 3 , 10 , 3000 ); System . out . println ( staff1 . toString ()); System . out . printf ( \"(Staff1) Salary: $ %.2f\" , staff1 . calculateSalary ()); System . out . println ( \"\\n\" ); PartTimeStaff staff2 = new PartTimeStaff ( \"Ivan Lam\" , \"XYZ787\" , 2 , 125 , 20 ); System . out . println ( staff2 . toString ()); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); staff2 . addHoursWorked ( 5 ); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); System . out . printf ( \"(Staff2) Salary: $ %.2f\" , staff1 . calculateSalary ()); } } Output: Full Name: Horace Diaz Staff ID: ABC123 Qualification Type: Doctorate Staff Rank: Professor (Staff1) Salary: $ 4000.00 Full Name: Ivan Lam Staff ID: XYZ787 Qualification Type: Master Staff Rank: Part-Time Lecturer (Staff2) Hours worked: 20 (Staff2) Hours worked: 25 (Staff2) Salary: $ 3125.00 Optional Activity: Subtype Polymorphism Subtype polymorphism (also known as subtyping or inclusion polymorphism) is a type of polymorphism in which an object can change its class based on its base class (superclass). Provided that the declaration is done using the object\u2019s base class, the object can substitute its class with any classes that are subclasses of that superclass. In our example, let's create yet another constructor in each of the subclasses to simulate a promotion/demotion act between full-time and part-time statuses. FullTimeStaff.java FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; switch ( this . rank ) { case 1 : this . baseSalary = 2000 ; break ; case 2 : this . baseSalary = 2500 ; break ; case 3 : this . baseSalary = 3000 ; break ; default : this . baseSalary = 0 ; } } public FullTimeStaff ( PartTimeStaff pt , int rank , int contributionHours ) { this ( pt . getFullName (), pt . getId (), pt . getQualificationLevel (), rank , contributionHours ); } /* ... */ } PartTimeStaff.java PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; hoursWorked = 0 ; } public PartTimeStaff ( FullTimeStaff ft , double hourlyRate ) { this ( ft . getFullName (), ft . getId (), ft . getQualificationLevel (), hourlyRate ); } /* ... */ } Try invoking these newly created constructors in your driver class to promote and demote the already created objects. Tasks Task 1 Consider the class diagram given below: Employee Superclass with Manager and Clerk Subclasses Implement all the classes as according to the given hierarchy. Write a test program that creates an array named empArray that stores an object of an Employee, a Manager, and a Clerk. In your program, include a method called printElements() that takes an array as a parameter and prints the type of employee, the object's data field values (by invoking the toString() method) and the monthly salary. Override the Object class' equals() method in Employee, Manager, and clerk classes. For each class, assume that two objects are considered equal if they have the same name. Test the equals() method on all derived types of Employee. Task 2 A bank offers its customers the following account types: The savings account earns interest that compounds monthly (i.e., the interest is calculated based on the balance on the last day of the month). The checking account has no interest, but the customer is given a small number of free transactions per month and is charged a nominal fee for each additional transaction. Create a superclass Account that has the properties account number, balance, and date created, as well as methods for deposit and withdrawal. Create two subclasses for saving and checking accounts. Write a test program that creates objects of the classes Account , SavingsAccount , and CheckingAccount .","title":"Practical 08: Polymorphism"},{"location":"archive/202108/lab08/#practical-08-polymorphism","text":"Polymorphism is another key concept in object-oriented programming. It refers to the capability of objects to react differently to the same method. Polymorphism can be implemented in the form of multiple methods having the same name. Java code uses a late-binding technique to support polymorphism; the method to be invoked is decided at runtime.","title":"Practical 08: Polymorphism"},{"location":"archive/202108/lab08/#activity-overloading-methods-vs-overriding-methods","text":"Overloaded methods are methods that have the same name, but different argument lists. Overriding , on the other hand, occurs when a subclass method has the same name, same return type, and same argument list as the superclass method.","title":"Activity: Overloading Methods vs. Overriding Methods"},{"location":"archive/202108/lab08/#overloading-methods","text":"One example of overloading methods that we have already covered during lecture when we first began going through classes and objects is through the use of multiple constructors. Going back to the previous activity, let's look at the FullTimeStaff class. Here, let's assume that if baseSalary isn't specified, it will be determined immediately by the rank entered. We'll now create a separate constructor method that takes in the same parameters, except baseSalary is excluded from this list. FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; switch ( this . rank ) { case 1 : this . baseSalary = 2000 ; break ; case 2 : this . baseSalary = 2500 ; break ; case 3 : this . baseSalary = 3000 ; break ; default : this . baseSalary = 0 ; } } /* ... */ } We can do the same with the PartTimeStaff class, but with hoursWorked undefined. In this case, hoursWorked to 0 if unspecified. PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; hoursWorked = 0 ; } /* ... */ } Overloading methods isn't just restricted to constructors; this can be applied from a procedural programming standpoint. Let's assume that this class has two methods that print out the area of a shape given two different sets of parameters. Shape.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Shape { // Get area of quadrilateral public double getArea ( double width , double height ) { return width * height ; } // Get area of circle public double getArea ( double radius ) { return Math . PI * radius * radius ; } /* ... */ } The key idea behind overloading methods is to have methods of the same name, but different argument lists . Here, depending on whether one double value or two double values are entered, you get two different methods of calculating the area of the shape. Overloading methods is also not restricted by the return type being used. For example, one may create a getArea() method that returns an integer value based on yet another argument list. The number of times a method is overloaded is not restricted as well, but ensure not to have ambiguous parameter lists like as follows: Shape.java 1 2 3 4 5 6 7 8 9 10 11 public class Shape { public double getArea ( double width , double height ) { /* ... */ } public double getArea ( double radius , int dimension ) { /* ... */ } /* ... */ } Here, the compiler does not know which method to use when invoked with a parameter list where the second number can be interpreted as either an integer or double.","title":"Overloading Methods"},{"location":"archive/202108/lab08/#overriding-methods","text":"Overriding methods involve having methods of the same name, return type, and argument list between superclass and subclass. Going back to last week's activity again, we will now override the toString() and calculateSalary() methods of both subclasses.","title":"Overriding Methods"},{"location":"archive/202108/lab08/#fulltimestaffjava","text":"FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class FullTimeStaff extends AcademicStaff { /* ... */ public double calculateSalary () { return baseSalary + getBonus (); } public String toString () { String rankName = \"\" ; switch ( rank ) { case 1 : rankName = \"Lecturer\" ; break ; case 2 : rankName = \"Senior Lecturer\" ; break ; case 3 : rankName = \"Professor\" ; break ; default : } return super . toString () + \"\\nStaff Rank: \" + rankName ; } }","title":"FullTimeStaff.java"},{"location":"archive/202108/lab08/#parttimestaffjava","text":"PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 public class PartTimeStaff extends AcademicStaff { /* ... */ public double calculateSalary () { return hourlyRate * hoursWorked ; } public String toString () { return super . toString () + \"\\nStaff Rank: Part-Time Lecturer\" ; } } In this example, we have already overriden toString() twice, once between the superclass and subclass we have just created, and the other via overriding from the Object class. In Java, all classes are considered subclasses of the Object class, which in turn, is the superclass of just about any class that exists in Java and any class you create. Java's Object class contains the toString() method by default, which prints out the memory address the object is taking up. This is not particularly helpful to us as regular users who pay no regard to where about the object is specifically being stored in the computer's memory. Making the following modifications to the main method in the driver class will render the following output: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Driver { public static void main ( String [] args ) { FullTimeStaff staff1 = new FullTimeStaff ( \"Horace Diaz\" , \"ABC123\" , 3 , 3 , 10 , 3000 ); System . out . println ( staff1 . toString ()); System . out . printf ( \"(Staff1) Salary: $ %.2f\" , staff1 . calculateSalary ()); System . out . println ( \"\\n\" ); PartTimeStaff staff2 = new PartTimeStaff ( \"Ivan Lam\" , \"XYZ787\" , 2 , 125 , 20 ); System . out . println ( staff2 . toString ()); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); staff2 . addHoursWorked ( 5 ); System . out . println ( \"(Staff2) Hours worked: \" + staff2 . getHoursWorked ()); System . out . printf ( \"(Staff2) Salary: $ %.2f\" , staff1 . calculateSalary ()); } } Output: Full Name: Horace Diaz Staff ID: ABC123 Qualification Type: Doctorate Staff Rank: Professor (Staff1) Salary: $ 4000.00 Full Name: Ivan Lam Staff ID: XYZ787 Qualification Type: Master Staff Rank: Part-Time Lecturer (Staff2) Hours worked: 20 (Staff2) Hours worked: 25 (Staff2) Salary: $ 3125.00","title":"PartTimeStaff.java"},{"location":"archive/202108/lab08/#optional-activity-subtype-polymorphism","text":"Subtype polymorphism (also known as subtyping or inclusion polymorphism) is a type of polymorphism in which an object can change its class based on its base class (superclass). Provided that the declaration is done using the object\u2019s base class, the object can substitute its class with any classes that are subclasses of that superclass. In our example, let's create yet another constructor in each of the subclasses to simulate a promotion/demotion act between full-time and part-time statuses.","title":"Optional Activity: Subtype Polymorphism"},{"location":"archive/202108/lab08/#fulltimestaffjava_1","text":"FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { // calls the superclass' constructor super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; this . baseSalary = baseSalary ; } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); this . rank = rank ; this . contributionHours = contributionHours ; switch ( this . rank ) { case 1 : this . baseSalary = 2000 ; break ; case 2 : this . baseSalary = 2500 ; break ; case 3 : this . baseSalary = 3000 ; break ; default : this . baseSalary = 0 ; } } public FullTimeStaff ( PartTimeStaff pt , int rank , int contributionHours ) { this ( pt . getFullName (), pt . getId (), pt . getQualificationLevel (), rank , contributionHours ); } /* ... */ }","title":"FullTimeStaff.java"},{"location":"archive/202108/lab08/#parttimestaffjava_1","text":"PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; this . hoursWorked = hoursWorked ; } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); this . hourlyRate = hourlyRate ; hoursWorked = 0 ; } public PartTimeStaff ( FullTimeStaff ft , double hourlyRate ) { this ( ft . getFullName (), ft . getId (), ft . getQualificationLevel (), hourlyRate ); } /* ... */ } Try invoking these newly created constructors in your driver class to promote and demote the already created objects.","title":"PartTimeStaff.java"},{"location":"archive/202108/lab08/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab08/#task-1","text":"Consider the class diagram given below: Employee Superclass with Manager and Clerk Subclasses Implement all the classes as according to the given hierarchy. Write a test program that creates an array named empArray that stores an object of an Employee, a Manager, and a Clerk. In your program, include a method called printElements() that takes an array as a parameter and prints the type of employee, the object's data field values (by invoking the toString() method) and the monthly salary. Override the Object class' equals() method in Employee, Manager, and clerk classes. For each class, assume that two objects are considered equal if they have the same name. Test the equals() method on all derived types of Employee.","title":"Task 1"},{"location":"archive/202108/lab08/#task-2","text":"A bank offers its customers the following account types: The savings account earns interest that compounds monthly (i.e., the interest is calculated based on the balance on the last day of the month). The checking account has no interest, but the customer is given a small number of free transactions per month and is charged a nominal fee for each additional transaction. Create a superclass Account that has the properties account number, balance, and date created, as well as methods for deposit and withdrawal. Create two subclasses for saving and checking accounts. Write a test program that creates objects of the classes Account , SavingsAccount , and CheckingAccount .","title":"Task 2"},{"location":"archive/202108/lab09/","text":"Practical 09: Abstract Classes and Interfaces If you look into the hierarchy of classes in Java, you may find that you are not able to create objects out of certain superclasses. This is often because having objects based on the structure of such superclasses don't make sense. In such cases like these, we often keep these classes (and sometimes some of their methods as well) as abstract. Activity: Implementing an Abstract Class and Abstract Methods Looking back at the program we just went through for the past two weeks, it is not very useful to have objects of just the Employee class. We can change it into an abstract class by adding the abstract keyword in the class declaration like as follows: AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ public double calculateSalary () { return 0 ; } } Here, we also modified the constructor declaration to use the protected keyword instead of the public keyword. It barely makes a difference for the time being, but it does ensure that it cannot be invoked unless from a linked subclass. Note that in this class, the calculateSalary() method is also not useful. Apart from creating abstract classes, the abstract keyword can be used to create abstract methods as and when necessary. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ public abstract double calculateSalary (); } Abstract methods can still be overridden by subclasses. However, the visibility modifier of such declarations cannot be more private than that implemented in the superclass. In this case, you are not allowed to override the calculateSalary() method with any other visibility modifier apart from public . However, if the declaration here in the superclass is protected for example, subclasses can use the same visibility modifier or use a less private one like public . AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ protected abstract double calculateSalary (); } Implementing a Simple Interface Let's create an interface class named Manners . We will only implement it in the AcademicStaff class, but the methods introduced from the Manners interface will be reflected on the related subclasses. This interface will have one method called introduce() , but there is no restriction as to how many methods are introduced here. Manners.java Manners.java public interface Manners { void introduce (); } In order to introduce the use of this interface in the AcademicStaff class, introduce it using the implements keyword like as follows: AcademicStaff.java 1 2 3 public class AcademicStaff implements Manners { /* ... */ } Note The usage of the implements keyword can be used alongside the extends keyword, should an interface ever need to be implemented on a subclass. When implementing an interface, one would require the method to be implemented. In the AcademicStaff class, assume that the introduce() prints out a greeting statement. AcademicStaff.java 1 2 3 4 5 6 7 public class AcademicStaff implements Manners { /* ... */ public void introduce () { System . out . println ( \"Hi, I'm \" + fullName + \"!\" ); } } Optional Activity How would you implement this interface in the subclasses should you want the introduce() method to act differently based on which subclass it is being called from? Task In this practical task, you will build simple programs using abstract classes. You will also learn how to add polymorphic behavior to the program using abstract methods. Product.java The skeleton code for Product.java is given below. The Product class is an abstract class that has an abstract method called computeSalePrice() . Product.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Product class is now an abstract class public abstract class Product { private double regularPrice ; // Creates a new instance of Product public Product ( double regularPrice ) { this . regularPrice = regularPrice ; } // computeSalesPrice() is now an abstract method public abstract double computeSalePrice (); public double getRegularPrice () { return regularPrice ; } public void setRegularPrice ( double regularPrice ) { this . regularPrice = regularPrice ; } } Electronics.java The Electronics class itself is an abstract class because it does not provide implementation of the computeSalePrice() abstract method. Electronics.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Electronics class is now an abstract class because it does not provide * implementation of the computeSalePrice() abstract method. */ public abstract class Electronics extends Product { private String manufacturer ; // Creates a new instance of Electronics public Electronics ( double regularPrice , String manufacturer ) { super ( regularPrice ); this . manufacturer = manufacturer ; } public String getManufacturer () { return manufacturer ; } public void setManufacturer ( String manufacturer ) { this . manufacturer = manufacturer ; } } Write MP3Player.java . The MP3Player class extends the Electronics class. The MP3Player class should implement the computeSalePrice() method with the following statement: return super . getRegularPrice () * 0.9 ; Note: In addition to the implementation of the abstract method, you might also need to include a constructor or instance variable. Write TV.java . The TV class extends the Electronics abstract class. The TV class should also implement the computeSalePrice() method, but with the following statement: return super . getRegularPrice () * 0.8 ; Note: In addition to the implementation of the abstract method, you might also need to include a constructor or instance variable. Complete Book.java . The Book class extends the Product class. The Book class should also implement the computeSalePrice() method, but with the following statement: return super . getRegularPrice () * 0.5 ; You may continue with the given code for Book.java as follows: Book.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Book extends Product { private String publisher ; private int yearPublished ; // Creates a new instance of Book public Book ( double regularPrice , String publisher , int yearPublished ) { super ( regularPrice ); } // Implement abstract method here public String getPublisher () { return publisher ; } public void setPublisher ( String publisher ) { this . publisher = publisher ; } public int getYearPublished () { return yearPublished ; } public void setYearPublished ( int yearPublished ) { this . yearPublished = yearPublished ; } } Run Main.java . Main.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Main { public static void main ( String [] args ) { // Declare and create Product array of size 5 Product [] pa = new Product [ 5 ] ; /** * Create object instances and assign them to * the type of Product. */ pa [ 0 ] = new TV ( 1000 , \"Samsung\" , 30 ); pa [ 1 ] = new TV ( 2000 , \"Sony\" , 50 ); pa [ 2 ] = new MP3Player ( 250 , \"Apple\" , \"blue\" ); pa [ 3 ] = new Book ( 34 , \"Sun Press\" , 1992 ); pa [ 4 ] = new Book ( 15 , \"Korea Press\" , 1986 ); // Compute total regular price and total sale price double totalRegularPrice = 0 ; double totalSalePrice = 0 ; for ( int i = 0 ; i < pa . length ; i ++ ) { /** * Call a method of the superclass to get * the regular price. */ totalRegularPrice += pa [ i ] . getRegularPrice (); /** * Since the sale price is computed differently * depending on the product type, overriding * (implementation) method of the object instance * of the subclass gets invoked. This is runtime * polymorphic behavior. */ totalSalePrice += pa [ i ] . computeSalePrice (); System . out . println ( \"Item number \" + i + \": Type = \" + pa [ i ] . getClass (). getName () + \", Regular price = \" + pa [ i ] . getRegularPrice () + \", Sale price = \" + pa [ i ] . computeSalePrice ()); } System . out . println ( \"totalRegularPrice = \" + totalRegularPrice ); System . out . println ( \"totalSalePrice = \" + totalSalePrice ); } } You should observe the following output results: Item number 0: Type = myonlineshop.TV, Regular price = 1000.0, Sale price = 800.0 Item number 1: Type = myonlineshop.TV, Regular price = 2000.0, Sale price = 1600.0 Item number 2: Type = myonlineshop.MP3Player, Regular price = 250.0, Sale price = 225.0 Item number 3: Type = myonlineshop.Book, Regular price = 34.0, Sale price = 17.0 Item number 4: Type = myonlineshop.Book, Regular price = 15.0, Sale price = 7.5 totalRegularPrice = 3299.0 totalSalePrice = 2649.5","title":"Practical 09: Abstract Classes and Interfaces"},{"location":"archive/202108/lab09/#practical-09-abstract-classes-and-interfaces","text":"If you look into the hierarchy of classes in Java, you may find that you are not able to create objects out of certain superclasses. This is often because having objects based on the structure of such superclasses don't make sense. In such cases like these, we often keep these classes (and sometimes some of their methods as well) as abstract.","title":"Practical 09: Abstract Classes and Interfaces"},{"location":"archive/202108/lab09/#activity-implementing-an-abstract-class-and-abstract-methods","text":"Looking back at the program we just went through for the past two weeks, it is not very useful to have objects of just the Employee class. We can change it into an abstract class by adding the abstract keyword in the class declaration like as follows: AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ public double calculateSalary () { return 0 ; } } Here, we also modified the constructor declaration to use the protected keyword instead of the public keyword. It barely makes a difference for the time being, but it does ensure that it cannot be invoked unless from a linked subclass. Note that in this class, the calculateSalary() method is also not useful. Apart from creating abstract classes, the abstract keyword can be used to create abstract methods as and when necessary. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ public abstract double calculateSalary (); } Abstract methods can still be overridden by subclasses. However, the visibility modifier of such declarations cannot be more private than that implemented in the superclass. In this case, you are not allowed to override the calculateSalary() method with any other visibility modifier apart from public . However, if the declaration here in the superclass is protected for example, subclasses can use the same visibility modifier or use a less private one like public . AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protected abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { this . fullName = fullName ; this . id = id ; this . qualificationLevel ; } /* ... */ protected abstract double calculateSalary (); }","title":"Activity: Implementing an Abstract Class and Abstract Methods"},{"location":"archive/202108/lab09/#implementing-a-simple-interface","text":"Let's create an interface class named Manners . We will only implement it in the AcademicStaff class, but the methods introduced from the Manners interface will be reflected on the related subclasses. This interface will have one method called introduce() , but there is no restriction as to how many methods are introduced here.","title":"Implementing a Simple Interface"},{"location":"archive/202108/lab09/#mannersjava","text":"Manners.java public interface Manners { void introduce (); } In order to introduce the use of this interface in the AcademicStaff class, introduce it using the implements keyword like as follows: AcademicStaff.java 1 2 3 public class AcademicStaff implements Manners { /* ... */ } Note The usage of the implements keyword can be used alongside the extends keyword, should an interface ever need to be implemented on a subclass. When implementing an interface, one would require the method to be implemented. In the AcademicStaff class, assume that the introduce() prints out a greeting statement. AcademicStaff.java 1 2 3 4 5 6 7 public class AcademicStaff implements Manners { /* ... */ public void introduce () { System . out . println ( \"Hi, I'm \" + fullName + \"!\" ); } }","title":"Manners.java"},{"location":"archive/202108/lab09/#optional-activity","text":"How would you implement this interface in the subclasses should you want the introduce() method to act differently based on which subclass it is being called from?","title":"Optional Activity"},{"location":"archive/202108/lab09/#task","text":"In this practical task, you will build simple programs using abstract classes. You will also learn how to add polymorphic behavior to the program using abstract methods.","title":"Task"},{"location":"archive/202108/lab09/#productjava","text":"The skeleton code for Product.java is given below. The Product class is an abstract class that has an abstract method called computeSalePrice() . Product.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Product class is now an abstract class public abstract class Product { private double regularPrice ; // Creates a new instance of Product public Product ( double regularPrice ) { this . regularPrice = regularPrice ; } // computeSalesPrice() is now an abstract method public abstract double computeSalePrice (); public double getRegularPrice () { return regularPrice ; } public void setRegularPrice ( double regularPrice ) { this . regularPrice = regularPrice ; } }","title":"Product.java"},{"location":"archive/202108/lab09/#electronicsjava","text":"The Electronics class itself is an abstract class because it does not provide implementation of the computeSalePrice() abstract method. Electronics.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Electronics class is now an abstract class because it does not provide * implementation of the computeSalePrice() abstract method. */ public abstract class Electronics extends Product { private String manufacturer ; // Creates a new instance of Electronics public Electronics ( double regularPrice , String manufacturer ) { super ( regularPrice ); this . manufacturer = manufacturer ; } public String getManufacturer () { return manufacturer ; } public void setManufacturer ( String manufacturer ) { this . manufacturer = manufacturer ; } } Write MP3Player.java . The MP3Player class extends the Electronics class. The MP3Player class should implement the computeSalePrice() method with the following statement: return super . getRegularPrice () * 0.9 ; Note: In addition to the implementation of the abstract method, you might also need to include a constructor or instance variable. Write TV.java . The TV class extends the Electronics abstract class. The TV class should also implement the computeSalePrice() method, but with the following statement: return super . getRegularPrice () * 0.8 ; Note: In addition to the implementation of the abstract method, you might also need to include a constructor or instance variable. Complete Book.java . The Book class extends the Product class. The Book class should also implement the computeSalePrice() method, but with the following statement: return super . getRegularPrice () * 0.5 ; You may continue with the given code for Book.java as follows: Book.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Book extends Product { private String publisher ; private int yearPublished ; // Creates a new instance of Book public Book ( double regularPrice , String publisher , int yearPublished ) { super ( regularPrice ); } // Implement abstract method here public String getPublisher () { return publisher ; } public void setPublisher ( String publisher ) { this . publisher = publisher ; } public int getYearPublished () { return yearPublished ; } public void setYearPublished ( int yearPublished ) { this . yearPublished = yearPublished ; } } Run Main.java . Main.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Main { public static void main ( String [] args ) { // Declare and create Product array of size 5 Product [] pa = new Product [ 5 ] ; /** * Create object instances and assign them to * the type of Product. */ pa [ 0 ] = new TV ( 1000 , \"Samsung\" , 30 ); pa [ 1 ] = new TV ( 2000 , \"Sony\" , 50 ); pa [ 2 ] = new MP3Player ( 250 , \"Apple\" , \"blue\" ); pa [ 3 ] = new Book ( 34 , \"Sun Press\" , 1992 ); pa [ 4 ] = new Book ( 15 , \"Korea Press\" , 1986 ); // Compute total regular price and total sale price double totalRegularPrice = 0 ; double totalSalePrice = 0 ; for ( int i = 0 ; i < pa . length ; i ++ ) { /** * Call a method of the superclass to get * the regular price. */ totalRegularPrice += pa [ i ] . getRegularPrice (); /** * Since the sale price is computed differently * depending on the product type, overriding * (implementation) method of the object instance * of the subclass gets invoked. This is runtime * polymorphic behavior. */ totalSalePrice += pa [ i ] . computeSalePrice (); System . out . println ( \"Item number \" + i + \": Type = \" + pa [ i ] . getClass (). getName () + \", Regular price = \" + pa [ i ] . getRegularPrice () + \", Sale price = \" + pa [ i ] . computeSalePrice ()); } System . out . println ( \"totalRegularPrice = \" + totalRegularPrice ); System . out . println ( \"totalSalePrice = \" + totalSalePrice ); } } You should observe the following output results: Item number 0: Type = myonlineshop.TV, Regular price = 1000.0, Sale price = 800.0 Item number 1: Type = myonlineshop.TV, Regular price = 2000.0, Sale price = 1600.0 Item number 2: Type = myonlineshop.MP3Player, Regular price = 250.0, Sale price = 225.0 Item number 3: Type = myonlineshop.Book, Regular price = 34.0, Sale price = 17.0 Item number 4: Type = myonlineshop.Book, Regular price = 15.0, Sale price = 7.5 totalRegularPrice = 3299.0 totalSalePrice = 2649.5","title":"Electronics.java"},{"location":"archive/202108/lab10/","text":"Practical 10: Exception Handling Unfortunately, we live in a tragic society where there exist individuals who are fascinated with breaking stuff, and those who would rather fight for the right to do whatever they so please. This is no different with programs, but this is one way on how bugs are discovered in programs. In this practical, let's start playing the devil's advocate and do all we can to patch such problems. Who says that there is absolutely nothing that can be done to prevent their actions from affecting others? Java provides Exception classes that can be used to cater for unintended occurrences. While utilizing Exceptions are always welcome, one should try to resort to using simpler tactics whenever possible (e.g., implementing checks with if-else statements). It is also worth noting that for some languages, utilizing exception handling is not strongly encouraged. Activity: Applying Exception Handling into a Program Let's revisit that Staff program we just around to developing these past three practical sessions. We'll begin with the abstract parent class AcademicStaff.java . AcademicStaff.java AcademicStaff.java has attributes fullName , id , and qualificationLevel . From the way we've implemented the qualificationLevel attribute, it can take one of 3 values: 1 (Bachelor), 2 (Master), or 3 (Doctorate). Let's make it such that when initializing an AcademicStaff object, it throws an Exception when any other value is received for qualificationLevel (not that it can now since it's abstract, but it will do the same for the subclasses). We will now modify the mutator method for this attribute like as follows: 1 2 3 4 5 6 public void setQualificationLevel ( int qualificationLevel ) { if ( qualificationLevel < 1 || qualificationLevel > 3 ) throw new IllegalArgumentException ( \"Qualification Level must be either 1, 2, or 3!\" ); this . qualificationLevel = qualificationLevel ; } Here, we are throwing an IllegalArgumentExcpetion back to the method that called it. The IllegalArgumentExcpetion class is one of many exception classes that exist in Java. This one in particular is best used here since we can regard a qualification level which is not one of the stated values (i.e., 1-3) as an illegal argument/value. FullTimeStaff.java The rank attribute follows the same convention as with the AcademicStaff 's qualificationLevel attribute. 1 2 3 4 5 6 public void setRank ( int rank ) { if ( rank < 1 || rank > 3 ) throw new IllegalArgumentException ( \"Rank must be either 1, 2, or 3!\" ); this . rank = rank ; } For both the contributionHours and baseSalary attributes, they are expected to contain non-negative values. We can proceed to throw an exception each time a negative value is entered, or we can set it to 0 instead (this does not require throwing an Exception, rather to implement an if-else statement). The choice is entirely up to you. Throwing an Exception 1 2 3 4 5 6 public void setContributionHours ( int contributionHours ) { if ( contributionHours < 0 ) throw new IllegalArgumentException ( \"Contribution hours cannot be negative!\" ); this . contributionHours = contributionHours ; } 1 2 3 4 5 6 public void setBaseSalary ( int baseSalary ) { if ( baseSalary < 0 ) throw new IllegalArgumentException ( \"Base salary cannot be negative!\" ); this . baseSalary = baseSalary ; } Defaulting to 0 1 2 3 4 5 6 public void setContributionHours ( int contributionHours ) { if ( contributionHours < 0 ) this . contributionHours = 0 ; else this . contributionHours = contributionHours ; } 1 2 3 4 5 6 public void setBaseSalary ( int baseSalary ) { if ( baseSalary < 0 ) this . baseSalary = 0 ; else this . baseSalary = baseSalary ; } PartTimeStaff.java The same approaches to FullTimeStaff 's attributes can be done for PartTimeStaff 's hourlyRate and hoursWorked attributes. Simply modify their mutator methods to work similarly. Apart from these mutator methods, we can also modify the addHoursWorked() method such that it will not take in negative values. In this case, reverting the hoursWorked value is not appropriate. Thus, you should throw an IllegalArgumentException object instead in its place. Forcing Constructors to Use Modified Mutator Methods Let's now modify the constructors in this class as well as the two subclasses such that they use the mutator methods by default when called. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { setFullName ( fullName ); setId ( id ); setQualificationLevel ( qualificationLevel ); } /* ... */ } FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { super ( fullName , id , qualificationLevel ); setRank ( rank ); setContributionHours ( contributionHours ); setBaseSalary ( baseSalary ); } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); setRank ( rank ); setContributionHours ( contributionHours ); switch ( this . rank ) { case 1 : setBaseSalary ( 2000 ); break ; case 2 : setBaseSalary ( 2500 ); break ; case 3 : setBaseSalary ( 3000 ); break ; default : setBaseSalary ( 0 ); } } public FullTimeStaff ( PartTimeStaff pt , int rank , int contributionHours ) { this ( pt . getFullName (), pt . getId (), pt . getQualificationLevel (), rank , contributionHours ); } /* ... */ } PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); setHourlyRate ( hourlyRate ); setHoursWorked ( hoursWorked ); } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); setHourlyRate ( hourlyRate ); setHoursWorked ( 0 ); } public PartTimeStaff ( FullTimeStaff ft , double hourlyRate ) { this ( ft . getFullName (), ft . getId (), ft . getQualificationLevel (), hourlyRate ); } /* ... */ } try-catch-finally block We've implemented the classes such that they throw the appropriate Exception classes as and when necessary. However, without specifying a method of catching such Exception classes, your program will not terminate gracefully. In the driver class' main method, surround your code with the try-catch block as follows: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Driver { public static void main ( String [] args ) { try { /* testing code goes here */ } catch ( IllegalArgumentException ex ) { System . out . println ( ex . getMessage ()); } catch ( Exception ex ) { ex . printStackTrace (); } } } The program is now set to check for Exception objects being thrown from anything that is called from the try block. Once the matching Exception object is caught, the program proceeds to run the statements from within that catch block. Whatever statements yet to be run from the try block is skipped. Notice that the program checks for an IllegalArgumentException object first before a more generic Exception object. In practice, you should cater to catch specific Exception types before ending with checking for objects of the generic Exception class. Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Driver { public static void main ( String [] args ) { try { /* testing code goes here */ } catch ( IllegalArgumentException ex ) { System . out . println ( ex . getMessage ()); } catch ( Exception ex ) { ex . printStackTrace (); } finally { System . out . println ( \"End of Staff program\" ); } } } Regardless of whether an Exception is caught, if a finally block exists, all statements from this block is run. Statements in the finally block can be used to close resources (e.g., for writing to files) or display specific messages (e.g., to signal the end of the program). Now, go bonkers and see if your attempts at securing your program a little better worked! Tasks Task 1 Write a program that prompts the user to read two integers and displays their multiplication. Your program should prompt the user to read the number again if the input is incorrect. Example Output: Enter two integers: 3 a Incorrect input! Re-enter two integers: a 3 Incorrect input! Re-enter two integers: 3 3 Multiplication is 9 Task 2 Write a program that meets the following requirements: Create an array with 100 randomly chosen integers. Prompt the user to enter the array index, then display the corresponding element value. If the specified index is out of bounds, display the message \"Index out of bounds\". Example Output: Enter an index: 101 Index out of bounds Enter an index: 55 The element is 7313 Enter an index: 108 Index out of bounds Task 3 Write a class named TestScores . The class constructor should accept any array of test scores as its argument. The class should have a method that returns the average of the test scores. If any test score in the array is negative or greater than 100 then the class should throw an IllegialArugumentException with the specified detail message to its caller. Demonstrate the usage of the class in a test program. Task 4 Write a program that uses the following method to solve equations specified by the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Returns the larger of the two roots of * the quadratic equation A*x*x + B*x + C = 0. * (Throws an exception if A == 0 or B*B-4*A*C < 0.) */ public static double root ( double A , double B , double C ) throws IllegalArgumentException { if ( A == 0 ) { throw new IllegalArgumentException ( \"A can't be zero.\" ); } else { double disc = B * B - 4 * A * C ; if ( disc < 0 ) throw new IllegalArgumentException ( \"Discriminant < zero.\" ); return ( - B + Math . sqrt ( disc )) / ( 2 * A ); } } Your program should allow the user to specify values for A , B , and C . It should call the method to compute a solution of the equation. If no error occurs, it should print the root. However, if an error occurs, your program should catch that error and print an error message. After processing one equation, the program should ask whether the user wants to enter another equation. The program should continue until the user answers no. Optional Task (Challenge Question) Write a calculator program. The program terminates if any operand is non-numeric. Write a program with an exception handler that deals with non-numeric operands; then write another program without using an exception handler to achieve the same objective. Your program should display a message that informs the user of the wrong operand type before exiting. Example Output: Input: 5 + y Wrong Input: y Input: 4f x 5 Wrong Input: 4f Input: 30 / 6 Output: 30 / 6 = 5","title":"Practical 10: Exception Handling"},{"location":"archive/202108/lab10/#practical-10-exception-handling","text":"Unfortunately, we live in a tragic society where there exist individuals who are fascinated with breaking stuff, and those who would rather fight for the right to do whatever they so please. This is no different with programs, but this is one way on how bugs are discovered in programs. In this practical, let's start playing the devil's advocate and do all we can to patch such problems. Who says that there is absolutely nothing that can be done to prevent their actions from affecting others? Java provides Exception classes that can be used to cater for unintended occurrences. While utilizing Exceptions are always welcome, one should try to resort to using simpler tactics whenever possible (e.g., implementing checks with if-else statements). It is also worth noting that for some languages, utilizing exception handling is not strongly encouraged.","title":"Practical 10: Exception Handling"},{"location":"archive/202108/lab10/#activity-applying-exception-handling-into-a-program","text":"Let's revisit that Staff program we just around to developing these past three practical sessions. We'll begin with the abstract parent class AcademicStaff.java .","title":"Activity: Applying Exception Handling into a Program"},{"location":"archive/202108/lab10/#academicstaffjava","text":"AcademicStaff.java has attributes fullName , id , and qualificationLevel . From the way we've implemented the qualificationLevel attribute, it can take one of 3 values: 1 (Bachelor), 2 (Master), or 3 (Doctorate). Let's make it such that when initializing an AcademicStaff object, it throws an Exception when any other value is received for qualificationLevel (not that it can now since it's abstract, but it will do the same for the subclasses). We will now modify the mutator method for this attribute like as follows: 1 2 3 4 5 6 public void setQualificationLevel ( int qualificationLevel ) { if ( qualificationLevel < 1 || qualificationLevel > 3 ) throw new IllegalArgumentException ( \"Qualification Level must be either 1, 2, or 3!\" ); this . qualificationLevel = qualificationLevel ; } Here, we are throwing an IllegalArgumentExcpetion back to the method that called it. The IllegalArgumentExcpetion class is one of many exception classes that exist in Java. This one in particular is best used here since we can regard a qualification level which is not one of the stated values (i.e., 1-3) as an illegal argument/value.","title":"AcademicStaff.java"},{"location":"archive/202108/lab10/#fulltimestaffjava","text":"The rank attribute follows the same convention as with the AcademicStaff 's qualificationLevel attribute. 1 2 3 4 5 6 public void setRank ( int rank ) { if ( rank < 1 || rank > 3 ) throw new IllegalArgumentException ( \"Rank must be either 1, 2, or 3!\" ); this . rank = rank ; } For both the contributionHours and baseSalary attributes, they are expected to contain non-negative values. We can proceed to throw an exception each time a negative value is entered, or we can set it to 0 instead (this does not require throwing an Exception, rather to implement an if-else statement). The choice is entirely up to you.","title":"FullTimeStaff.java"},{"location":"archive/202108/lab10/#throwing-an-exception","text":"1 2 3 4 5 6 public void setContributionHours ( int contributionHours ) { if ( contributionHours < 0 ) throw new IllegalArgumentException ( \"Contribution hours cannot be negative!\" ); this . contributionHours = contributionHours ; } 1 2 3 4 5 6 public void setBaseSalary ( int baseSalary ) { if ( baseSalary < 0 ) throw new IllegalArgumentException ( \"Base salary cannot be negative!\" ); this . baseSalary = baseSalary ; }","title":"Throwing an Exception"},{"location":"archive/202108/lab10/#defaulting-to-0","text":"1 2 3 4 5 6 public void setContributionHours ( int contributionHours ) { if ( contributionHours < 0 ) this . contributionHours = 0 ; else this . contributionHours = contributionHours ; } 1 2 3 4 5 6 public void setBaseSalary ( int baseSalary ) { if ( baseSalary < 0 ) this . baseSalary = 0 ; else this . baseSalary = baseSalary ; }","title":"Defaulting to 0"},{"location":"archive/202108/lab10/#parttimestaffjava","text":"The same approaches to FullTimeStaff 's attributes can be done for PartTimeStaff 's hourlyRate and hoursWorked attributes. Simply modify their mutator methods to work similarly. Apart from these mutator methods, we can also modify the addHoursWorked() method such that it will not take in negative values. In this case, reverting the hoursWorked value is not appropriate. Thus, you should throw an IllegalArgumentException object instead in its place.","title":"PartTimeStaff.java"},{"location":"archive/202108/lab10/#forcing-constructors-to-use-modified-mutator-methods","text":"Let's now modify the constructors in this class as well as the two subclasses such that they use the mutator methods by default when called. AcademicStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class AcademicStaff { private String fullName ; private String id ; private int qualificationLevel ; // Constructor protected AcademicStaff ( String fullName , String id , int qualificationLevel ) { setFullName ( fullName ); setId ( id ); setQualificationLevel ( qualificationLevel ); } /* ... */ } FullTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class FullTimeStaff extends AcademicStaff { private int rank ; private int contributionHours ; private double baseSalary ; // Constructors public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours , double baseSalary ) { super ( fullName , id , qualificationLevel ); setRank ( rank ); setContributionHours ( contributionHours ); setBaseSalary ( baseSalary ); } public FullTimeStaff ( String fullName , String id , int qualificationLevel , int rank , int contributionHours ) { super ( fullName , id , qualificationLevel ); setRank ( rank ); setContributionHours ( contributionHours ); switch ( this . rank ) { case 1 : setBaseSalary ( 2000 ); break ; case 2 : setBaseSalary ( 2500 ); break ; case 3 : setBaseSalary ( 3000 ); break ; default : setBaseSalary ( 0 ); } } public FullTimeStaff ( PartTimeStaff pt , int rank , int contributionHours ) { this ( pt . getFullName (), pt . getId (), pt . getQualificationLevel (), rank , contributionHours ); } /* ... */ } PartTimeStaff.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class PartTimeStaff extends AcademicStaff { private double hourlyRate ; private int hoursWorked ; // Constructors public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate , int hoursWorked ) { super ( fullName , id , qualificationLevel ); setHourlyRate ( hourlyRate ); setHoursWorked ( hoursWorked ); } public PartTimeStaff ( String fullName , String id , int qualificationLevel , double hourlyRate ) { super ( fullName , id , qualificationLevel ); setHourlyRate ( hourlyRate ); setHoursWorked ( 0 ); } public PartTimeStaff ( FullTimeStaff ft , double hourlyRate ) { this ( ft . getFullName (), ft . getId (), ft . getQualificationLevel (), hourlyRate ); } /* ... */ }","title":"Forcing Constructors to Use Modified Mutator Methods"},{"location":"archive/202108/lab10/#try-catch-finally-block","text":"We've implemented the classes such that they throw the appropriate Exception classes as and when necessary. However, without specifying a method of catching such Exception classes, your program will not terminate gracefully. In the driver class' main method, surround your code with the try-catch block as follows: Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Driver { public static void main ( String [] args ) { try { /* testing code goes here */ } catch ( IllegalArgumentException ex ) { System . out . println ( ex . getMessage ()); } catch ( Exception ex ) { ex . printStackTrace (); } } } The program is now set to check for Exception objects being thrown from anything that is called from the try block. Once the matching Exception object is caught, the program proceeds to run the statements from within that catch block. Whatever statements yet to be run from the try block is skipped. Notice that the program checks for an IllegalArgumentException object first before a more generic Exception object. In practice, you should cater to catch specific Exception types before ending with checking for objects of the generic Exception class. Driver.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Driver { public static void main ( String [] args ) { try { /* testing code goes here */ } catch ( IllegalArgumentException ex ) { System . out . println ( ex . getMessage ()); } catch ( Exception ex ) { ex . printStackTrace (); } finally { System . out . println ( \"End of Staff program\" ); } } } Regardless of whether an Exception is caught, if a finally block exists, all statements from this block is run. Statements in the finally block can be used to close resources (e.g., for writing to files) or display specific messages (e.g., to signal the end of the program). Now, go bonkers and see if your attempts at securing your program a little better worked!","title":"try-catch-finally block"},{"location":"archive/202108/lab10/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab10/#task-1","text":"Write a program that prompts the user to read two integers and displays their multiplication. Your program should prompt the user to read the number again if the input is incorrect. Example Output: Enter two integers: 3 a Incorrect input! Re-enter two integers: a 3 Incorrect input! Re-enter two integers: 3 3 Multiplication is 9","title":"Task 1"},{"location":"archive/202108/lab10/#task-2","text":"Write a program that meets the following requirements: Create an array with 100 randomly chosen integers. Prompt the user to enter the array index, then display the corresponding element value. If the specified index is out of bounds, display the message \"Index out of bounds\". Example Output: Enter an index: 101 Index out of bounds Enter an index: 55 The element is 7313 Enter an index: 108 Index out of bounds","title":"Task 2"},{"location":"archive/202108/lab10/#task-3","text":"Write a class named TestScores . The class constructor should accept any array of test scores as its argument. The class should have a method that returns the average of the test scores. If any test score in the array is negative or greater than 100 then the class should throw an IllegialArugumentException with the specified detail message to its caller. Demonstrate the usage of the class in a test program.","title":"Task 3"},{"location":"archive/202108/lab10/#task-4","text":"Write a program that uses the following method to solve equations specified by the user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Returns the larger of the two roots of * the quadratic equation A*x*x + B*x + C = 0. * (Throws an exception if A == 0 or B*B-4*A*C < 0.) */ public static double root ( double A , double B , double C ) throws IllegalArgumentException { if ( A == 0 ) { throw new IllegalArgumentException ( \"A can't be zero.\" ); } else { double disc = B * B - 4 * A * C ; if ( disc < 0 ) throw new IllegalArgumentException ( \"Discriminant < zero.\" ); return ( - B + Math . sqrt ( disc )) / ( 2 * A ); } } Your program should allow the user to specify values for A , B , and C . It should call the method to compute a solution of the equation. If no error occurs, it should print the root. However, if an error occurs, your program should catch that error and print an error message. After processing one equation, the program should ask whether the user wants to enter another equation. The program should continue until the user answers no.","title":"Task 4"},{"location":"archive/202108/lab10/#optional-task-challenge-question","text":"Write a calculator program. The program terminates if any operand is non-numeric. Write a program with an exception handler that deals with non-numeric operands; then write another program without using an exception handler to achieve the same objective. Your program should display a message that informs the user of the wrong operand type before exiting. Example Output: Input: 5 + y Wrong Input: y Input: 4f x 5 Wrong Input: 4f Input: 30 / 6 Output: 30 / 6 = 5","title":"Optional Task (Challenge Question)"},{"location":"archive/202108/lab11/","text":"Practical 11: File I/O A useful application of classes and exception handling in Java is File I/O. In this practical activity, we will utilize classes specifically meant to carry out file I/O with text files. Tasks Task 1 Write a program that reads from Exercise1.txt and counts the number of characters, words, and lines in a file. Words are separated by whitespace characters. Exercise1.txt Task 2 Suppose that a text file (Exercise2.txt) contains an unspecified number of scores separated by blanks. Write a program that prompts the user to enter the file, reads the scores from the file, and displays their total and average. Exercise2.txt Task 3 Write a program that creates a file named Exercise3.txt if it does not already exist. Write 100 randomly generated integers into this file using text I/O. Integers are to be separated by spaces in the file. Read the data back from the file and display the data in increasing order. Task 4 Write a program that prompts the user to enter a file name and displays the occurrences of each letter in the file. Letters are case-insensitive. Here is a sample run: Enter file name: Exercise1.txt The occurrence of A's is 22 The occurrence of B's is 6 The occurrence of C's is 4 The occurrence of D's is 6 The occurrence of E's is 28 The occurrence of F's is 4 The occurrence of G's is 1 The occurrence of H's is 3 The occurrence of I's is 5 The occurrence of J's is 14 The occurrence of K's is 2 The occurrence of L's is 7 The occurrence of M's is 6 The occurrence of N's is 4 The occurrence of O's is 7 The occurrence of P's is 4 The occurrence of Q's is 0 The occurrence of R's is 15 The occurrence of S's is 16 The occurrence of T's is 5 The occurrence of U's is 6 The occurrence of V's is 6 The occurrence of W's is 1 The occurrence of X's is 0 The occurrence of Y's is 7 The occurrence of Z's is 0","title":"Practical 11: File I/O"},{"location":"archive/202108/lab11/#practical-11-file-io","text":"A useful application of classes and exception handling in Java is File I/O. In this practical activity, we will utilize classes specifically meant to carry out file I/O with text files.","title":"Practical 11: File I/O"},{"location":"archive/202108/lab11/#tasks","text":"","title":"Tasks"},{"location":"archive/202108/lab11/#task-1","text":"Write a program that reads from Exercise1.txt and counts the number of characters, words, and lines in a file. Words are separated by whitespace characters. Exercise1.txt","title":"Task 1"},{"location":"archive/202108/lab11/#task-2","text":"Suppose that a text file (Exercise2.txt) contains an unspecified number of scores separated by blanks. Write a program that prompts the user to enter the file, reads the scores from the file, and displays their total and average. Exercise2.txt","title":"Task 2"},{"location":"archive/202108/lab11/#task-3","text":"Write a program that creates a file named Exercise3.txt if it does not already exist. Write 100 randomly generated integers into this file using text I/O. Integers are to be separated by spaces in the file. Read the data back from the file and display the data in increasing order.","title":"Task 3"},{"location":"archive/202108/lab11/#task-4","text":"Write a program that prompts the user to enter a file name and displays the occurrences of each letter in the file. Letters are case-insensitive. Here is a sample run: Enter file name: Exercise1.txt The occurrence of A's is 22 The occurrence of B's is 6 The occurrence of C's is 4 The occurrence of D's is 6 The occurrence of E's is 28 The occurrence of F's is 4 The occurrence of G's is 1 The occurrence of H's is 3 The occurrence of I's is 5 The occurrence of J's is 14 The occurrence of K's is 2 The occurrence of L's is 7 The occurrence of M's is 6 The occurrence of N's is 4 The occurrence of O's is 7 The occurrence of P's is 4 The occurrence of Q's is 0 The occurrence of R's is 15 The occurrence of S's is 16 The occurrence of T's is 5 The occurrence of U's is 6 The occurrence of V's is 6 The occurrence of W's is 1 The occurrence of X's is 0 The occurrence of Y's is 7 The occurrence of Z's is 0","title":"Task 4"}]}